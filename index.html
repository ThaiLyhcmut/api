<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mongoose Complete API Reference</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 15px;
      border-bottom: 3px solid #3498db;
      font-size: 2.5em;
    }

    .export-section {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #4ecdc4, #44a08d);
      border-radius: 10px;
      color: white;
    }

    .export-btn {
      background: #e74c3c;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      margin: 10px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .export-btn:hover {
      background: #c0392b;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: linear-gradient(135deg, #ff7e5f, #feb47b);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      color: white;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .stat-number {
      font-size: 2.5em;
      font-weight: bold;
      display: block;
    }

    .stat-label {
      font-size: 1.1em;
      margin-top: 5px;
    }

    .controls {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .search-container {
      margin-bottom: 20px;
    }

    .search-input {
      width: 100%;
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      box-sizing: border-box;
      transition: border-color 0.3s;
    }

    .search-input:focus {
      outline: none;
      border-color: #3498db;
      box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
    }

    .filter-section {
      margin-bottom: 20px;
    }

    .filter-title {
      font-weight: bold;
      margin-bottom: 10px;
      color: #2c3e50;
    }

    .filter-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }

    .filter-btn {
      background: #ecf0f1;
      border: 2px solid #bdc3c7;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 500;
      font-size: 14px;
    }

    .filter-btn:hover,
    .filter-btn.active {
      background: #3498db;
      color: white;
      border-color: #3498db;
      transform: translateY(-1px);
    }

    .category-btn {
      padding: 10px 20px;
      font-size: 16px;
      font-weight: bold;
    }

    .category-btn.active {
      background: #e74c3c;
      border-color: #e74c3c;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background: white;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      overflow: hidden;
    }

    th,
    td {
      padding: 15px;
      text-align: left;
      border-bottom: 1px solid #ddd;
      vertical-align: top;
    }

    th {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    tr:hover {
      background-color: #f8f9fa;
      transform: scale(1.005);
      transition: all 0.2s;
    }

    .api-name {
      font-family: 'Courier New', monospace;
      background: #e8f4f8;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: bold;
      color: #2c3e50;
      display: inline-block;
    }

    .type-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
      margin-right: 5px;
    }

    .category-badge {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 15px;
      font-size: 11px;
      font-weight: bold;
      text-transform: uppercase;
      margin-bottom: 5px;
    }

    /* Category colors */
    .category-mongoose {
      background: #9b59b6;
      color: white;
    }

    .category-schema {
      background: #3498db;
      color: white;
    }

    .category-model {
      background: #e67e22;
      color: white;
    }

    .category-document {
      background: #2ecc71;
      color: white;
    }

    .category-query {
      background: #f39c12;
      color: white;
    }

    /* Type colors */
    .type-constructor {
      background: #e74c3c;
      color: white;
    }

    .type-method {
      background: #2ecc71;
      color: white;
    }

    .type-property {
      background: #f39c12;
      color: white;
    }

    .type-static {
      background: #9b59b6;
      color: white;
    }

    .code-block {
      background: #2c3e50;
      color: #ecf0f1;
      padding: 12px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      margin: 8px 0;
      overflow-x: auto;
      white-space: pre-wrap;
    }

    .description {
      line-height: 1.6;
    }

    .hidden {
      display: none;
    }

    .category-info {
      background: #e8f4f8;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      border-left: 5px solid #3498db;
    }

    .category-title {
      font-size: 1.2em;
      font-weight: bold;
      color: #2c3e50;
      margin-bottom: 5px;
    }

    .category-description {
      color: #7f8c8d;
      margin: 0;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #7f8c8d;
      font-size: 18px;
    }

    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }

      .filter-container {
        justify-content: center;
      }

      table {
        font-size: 14px;
      }

      th,
      td {
        padding: 10px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üçÉ Mongoose Complete API Reference</h1>

    <div class="export-section">
      <h2>üìä Xu·∫•t d·ªØ li·ªáu ra Excel</h2>
      <p>T·∫£i xu·ªëng file Excel ch·ª©a t·∫•t c·∫£ th√¥ng tin v·ªÅ Mongoose API</p>
      <button class="export-btn" onclick="exportToExcel()">
        üì• T·∫£i xu·ªëng Excel
      </button>
    </div>

    <div class="stats-container" id="statsContainer">
      <!-- Stats will be populated by JavaScript -->
    </div>

    <div class="controls">
      <div class="search-container">
        <input type="text" class="search-input" placeholder="üîç T√¨m ki·∫øm API..." oninput="filterTable(this.value)">
      </div>

      <div class="filter-section">
        <div class="filter-title">üìÇ Ch·ªçn danh m·ª•c:</div>
        <div class="filter-container" id="categoryFilters">
          <!-- Category filters will be populated by JavaScript -->
        </div>
      </div>

      <div class="filter-section">
        <div class="filter-title">üè∑Ô∏è L·ªçc theo lo·∫°i:</div>
        <div class="filter-container" id="typeFilters">
          <!-- Type filters will be populated by JavaScript -->
        </div>
      </div>
    </div>

    <div class="category-info" id="categoryInfo">
      <div class="category-title" id="categoryTitle">T·∫•t c·∫£ API</div>
      <p class="category-description" id="categoryDescription">Hi·ªÉn th·ªã t·∫•t c·∫£ API c·ªßa Mongoose</p>
    </div>

    <table id="mongooseTable">
      <thead>
        <tr>
          <th style="width: 20%;">API Name</th>
          <th style="width: 10%;">Category</th>
          <th style="width: 10%;">Type</th>
          <th style="width: 35%;">Description</th>
          <th style="width: 25%;">Example</th>
        </tr>
      </thead>
      <tbody id="tableBody">
        <tr>
          <td colspan="5" class="loading">‚è≥ ƒêang t·∫£i d·ªØ li·ªáu...</td>
        </tr>
      </tbody>
    </table>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    // Data structure for different API categories
    const apiData = {
      mongoose: [
        {
          name: "Mongoose()",
          category: "mongoose",
          type: "constructor",
          description: "Constructor ch√≠nh c·ªßa Mongoose. T·∫°o m·ªôt instance m·ªõi c·ªßa Mongoose v·ªõi c√°c thi·∫øt l·∫≠p ri√™ng bi·ªát.",
          usage: "const mongoose = require('mongoose');",
          example: "const customMongoose = new mongoose.Mongoose();\ncustomMongoose.connect('mongodb://localhost/mydb');"
        },
        {
          name: "connect()",
          category: "mongoose",
          type: "method",
          description: "K·∫øt n·ªëi t·ªõi MongoDB database. Tr·∫£ v·ªÅ Promise.",
          usage: "mongoose.connect(uri, options)",
          example: "mongoose.connect('mongodb://localhost:27017/myapp', {\n  useNewUrlParser: true\n});"
        },
        {
          name: "model()",
          category: "mongoose",
          type: "method",
          description: "ƒê·ªãnh nghƒ©a model ho·∫∑c l·∫•y model ƒë√£ t·ªìn t·∫°i. Central method ƒë·ªÉ t·∫°o models.",
          usage: "mongoose.model(name, schema, collection)",
          example: "const User = mongoose.model('User', userSchema);\n// T·∫°o model m·ªõi"
        },
        {
          name: "Schema()",
          category: "mongoose",
          type: "constructor",
          description: "Constructor cho Schema. ƒê·ªãnh nghƒ©a c·∫•u tr√∫c document, validation rules v√† middleware.",
          usage: "new mongoose.Schema(definition, options)",
          example: "const userSchema = new mongoose.Schema({\n  name: String,\n  age: Number\n});"
        },
        {
          name: "connection",
          category: "mongoose",
          type: "property",
          description: "Default connection object. ƒê·∫°i di·ªán cho k·∫øt n·ªëi m·∫∑c ƒë·ªãnh t·ªõi MongoDB.",
          usage: "mongoose.connection",
          example: "mongoose.connection.on('connected', () => \n  console.log('Connected to MongoDB')\n);"
        }
      ],
      schema: [
        {
          name: "Schema()",
          category: "schema",
          type: "constructor",
          description: "Constructor ƒë·ªÉ t·∫°o schema m·ªõi. ƒê·ªãnh nghƒ©a c·∫•u tr√∫c v√† quy t·∫Øc cho documents.",
          usage: "new Schema(definition, options)",
          example: "const userSchema = new Schema({\n  name: { type: String, required: true },\n  age: Number\n});"
        },
        {
          name: "Schema.Types",
          category: "schema",
          type: "static",
          description: "Object ch·ª©a t·∫•t c·∫£ c√°c schema types c√≥ s·∫µn nh∆∞ String, Number, Date, ObjectId, etc.",
          usage: "Schema.Types.TypeName",
          example: "const schema = new Schema({\n  _id: Schema.Types.ObjectId,\n  price: Schema.Types.Decimal128\n});"
        },
        {
          name: "Schema.indexTypes",
          category: "schema",
          type: "static",
          description: "Array ch·ª©a c√°c lo·∫°i index ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi MongoDB.",
          usage: "Schema.indexTypes",
          example: "console.log(Schema.indexTypes);\n// ['1', '-1', 'text', '2d', '2dsphere', 'hashed']"
        },
        {
          name: "add()",
          category: "schema",
          type: "method",
          description: "Th√™m c√°c path m·ªõi v√†o schema. Cho ph√©p m·ªü r·ªông schema sau khi ƒë√£ t·∫°o.",
          usage: "schema.add(obj, prefix)",
          example: "userSchema.add({\n  email: String,\n  profile: {\n    bio: String,\n    avatar: String\n  }\n});"
        },
        {
          name: "alias()",
          category: "schema",
          type: "method",
          description: "T·∫°o alias cho m·ªôt path. Cho ph√©p s·ª≠ d·ª•ng t√™n kh√°c ƒë·ªÉ truy c·∫≠p c√πng m·ªôt field.",
          usage: "schema.alias(from, to)",
          example: "userSchema.alias('_id', 'id');\n// C√≥ th·ªÉ d√πng user.id thay v√¨ user._id"
        },
        {
          name: "childSchemas",
          category: "schema",
          type: "property",
          description: "Array ch·ª©a t·∫•t c·∫£ c√°c child schemas (subdocument schemas) c·ªßa schema n√†y.",
          usage: "schema.childSchemas",
          example: "console.log(userSchema.childSchemas);\n// [{ schema: addressSchema, model: Address }]"
        },
        {
          name: "clearIndexes()",
          category: "schema",
          type: "method",
          description: "X√≥a t·∫•t c·∫£ indexes ƒë√£ ƒë·ªãnh nghƒ©a trong schema.",
          usage: "schema.clearIndexes()",
          example: "userSchema.clearIndexes();\nconsole.log(userSchema.indexes()); // []"
        },
        {
          name: "clone()",
          category: "schema",
          type: "method",
          description: "T·∫°o m·ªôt b·∫£n sao c·ªßa schema. H·ªØu √≠ch khi mu·ªën t·∫°o schema t∆∞∆°ng t·ª± nh∆∞ng c√≥ m·ªôt s·ªë kh√°c bi·ªát.",
          usage: "schema.clone()",
          example: "const adminSchema = userSchema.clone();\nadminSchema.add({ permissions: [String] });"
        },
        {
          name: "discriminator()",
          category: "schema",
          type: "method",
          description: "T·∫°o discriminator schema. Cho ph√©p inheritance trong MongoDB v·ªõi __t field.",
          usage: "schema.discriminator(name, schema)",
          example: "const eventSchema = new Schema({ time: Date });\nconst clickEventSchema = eventSchema.discriminator('ClickEvent', \n  new Schema({ element: String })\n);"
        },
        {
          name: "eachPath()",
          category: "schema",
          type: "method",
          description: "L·∫∑p qua t·∫•t c·∫£ paths trong schema. Th·ª±c thi callback cho m·ªói path.",
          usage: "schema.eachPath(callback)",
          example: "userSchema.eachPath((path, type) => {\n  console.log(`${path}: ${type.constructor.name}`);\n});"
        },
        {
          name: "get()",
          category: "schema",
          type: "method",
          description: "L·∫•y gi√° tr·ªã c·ªßa schema option. ƒê·ªçc c√°c thi·∫øt l·∫≠p c·∫•u h√¨nh c·ªßa schema.",
          usage: "schema.get(key)",
          example: "const strict = userSchema.get('strict');\nconsole.log('Strict mode:', strict);"
        },
        {
          name: "index()",
          category: "schema",
          type: "method",
          description: "ƒê·ªãnh nghƒ©a index cho schema. T·∫°o c√°c index ƒë·ªÉ t·ªëi ∆∞u h√≥a truy v·∫•n.",
          usage: "schema.index(fields, options)",
          example: "userSchema.index({ email: 1 }, { unique: true });\nuserSchema.index({ name: 'text', bio: 'text' });"
        },
        {
          name: "indexes()",
          category: "schema",
          type: "method",
          description: "Tr·∫£ v·ªÅ array ch·ª©a t·∫•t c·∫£ indexes ƒë√£ ƒë·ªãnh nghƒ©a trong schema.",
          usage: "schema.indexes()",
          example: "const indexes = userSchema.indexes();\nconsole.log(indexes);\n// [{ email: 1 }, { name: 'text' }]"
        },
        {
          name: "loadClass()",
          category: "schema",
          type: "method",
          description: "Load c√°c methods v√† statics t·ª´ ES6 class v√†o schema.",
          usage: "schema.loadClass(Class)",
          example: "class UserClass {\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\nuserSchema.loadClass(UserClass);"
        },
        {
          name: "method()",
          category: "schema",
          type: "method",
          description: "Th√™m instance method v√†o schema. Methods n√†y s·∫Ω c√≥ s·∫µn tr√™n m·ªçi document.",
          usage: "schema.method(name, fn) ho·∫∑c schema.method(obj)",
          example: "userSchema.method('getFullName', function() {\n  return this.firstName + ' ' + this.lastName;\n});"
        },
        {
          name: "obj",
          category: "schema",
          type: "property",
          description: "Object ch·ª©a ƒë·ªãnh nghƒ©a g·ªëc c·ªßa schema. Raw schema definition.",
          usage: "schema.obj",
          example: "console.log(userSchema.obj);\n// { name: String, age: Number, email: String }"
        },
        {
          name: "omit()",
          category: "schema",
          type: "method",
          description: "T·∫°o schema m·ªõi b·∫±ng c√°ch lo·∫°i b·ªè c√°c paths ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh.",
          usage: "schema.omit(paths)",
          example: "const publicUserSchema = userSchema.omit(['password', 'secretKey']);"
        },
        {
          name: "path()",
          category: "schema",
          type: "method",
          description: "L·∫•y ho·∫∑c thi·∫øt l·∫≠p path trong schema. Truy c·∫≠p SchemaType instance.",
          usage: "schema.path(path, schemaType)",
          example: "const nameType = userSchema.path('name');\nconsole.log(nameType.instance); // 'String'"
        },
        {
          name: "pathType()",
          category: "schema",
          type: "method",
          description: "Tr·∫£ v·ªÅ lo·∫°i path: 'real', 'virtual', 'nested', 'adhocOrUndefined'.",
          usage: "schema.pathType(path)",
          example: "console.log(userSchema.pathType('name')); // 'real'\nconsole.log(userSchema.pathType('profile.bio')); // 'nested'"
        },
        {
          name: "paths",
          category: "schema",
          type: "property",
          description: "Object ch·ª©a t·∫•t c·∫£ paths trong schema, key l√† path name, value l√† SchemaType.",
          usage: "schema.paths",
          example: "console.log(Object.keys(userSchema.paths));\n// ['_id', 'name', 'age', 'email']"
        },
        {
          name: "pick()",
          category: "schema",
          type: "method",
          description: "T·∫°o schema m·ªõi ch·ªâ ch·ª©a c√°c paths ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh.",
          usage: "schema.pick(paths)",
          example: "const basicUserSchema = userSchema.pick(['name', 'email']);"
        },
        {
          name: "plugin()",
          category: "schema",
          type: "method",
          description: "√Åp d·ª•ng plugin cho schema. Th√™m functionality t·ª´ b√™n ngo√†i.",
          usage: "schema.plugin(fn, options)",
          example: "const timestamps = require('mongoose-timestamp');\nuserSchema.plugin(timestamps);"
        },
        {
          name: "post()",
          category: "schema",
          type: "method",
          description: "ƒê·ªãnh nghƒ©a post middleware. Ch·∫°y sau khi operation ho√†n th√†nh.",
          usage: "schema.post(method, fn)",
          example: "userSchema.post('save', function(doc) {\n  console.log('User saved:', doc.name);\n});"
        },
        {
          name: "pre()",
          category: "schema",
          type: "method",
          description: "ƒê·ªãnh nghƒ©a pre middleware. Ch·∫°y tr∆∞·ªõc khi operation ƒë∆∞·ª£c th·ª±c thi.",
          usage: "schema.pre(method, fn)",
          example: "userSchema.pre('save', function() {\n  this.updatedAt = new Date();\n});"
        },
        {
          name: "queue()",
          category: "schema",
          type: "method",
          description: "Th√™m function v√†o compile queue. Function s·∫Ω ƒë∆∞·ª£c g·ªçi khi model ƒë∆∞·ª£c compile.",
          usage: "schema.queue(method, args)",
          example: "userSchema.queue('index', [{ email: 1 }, { unique: true }]);"
        },
        {
          name: "remove()",
          category: "schema",
          type: "method",
          description: "X√≥a paths kh·ªèi schema. Lo·∫°i b·ªè c√°c fields kh√¥ng c·∫ßn thi·∫øt.",
          usage: "schema.remove(paths)",
          example: "userSchema.remove(['temporaryField', 'obsoleteData']);"
        },
        {
          name: "removeIndex()",
          category: "schema",
          type: "method",
          description: "X√≥a index kh·ªèi schema definition.",
          usage: "schema.removeIndex(index)",
          example: "userSchema.removeIndex({ email: 1 });"
        },
        {
          name: "removeVirtual()",
          category: "schema",
          type: "method",
          description: "X√≥a virtual field kh·ªèi schema.",
          usage: "schema.removeVirtual(name)",
          example: "userSchema.removeVirtual('fullName');"
        },
        {
          name: "requiredPaths()",
          category: "schema",
          type: "method",
          description: "Tr·∫£ v·ªÅ array ch·ª©a t·∫•t c·∫£ paths b·∫Øt bu·ªôc trong schema.",
          usage: "schema.requiredPaths(invalidate)",
          example: "const required = userSchema.requiredPaths();\nconsole.log(required); // ['name', 'email']"
        },
        {
          name: "set()",
          category: "schema",
          type: "method",
          description: "Thi·∫øt l·∫≠p schema option. C·∫•u h√¨nh c√°c thi·∫øt l·∫≠p cho schema.",
          usage: "schema.set(key, value) ho·∫∑c schema.set(obj)",
          example: "userSchema.set('timestamps', true);\nuserSchema.set('strict', false);"
        },
        {
          name: "static()",
          category: "schema",
          type: "method",
          description: "Th√™m static method v√†o schema. Methods n√†y s·∫Ω c√≥ s·∫µn tr√™n Model.",
          usage: "schema.static(name, fn) ho·∫∑c schema.static(obj)",
          example: "userSchema.static('findByEmail', function(email) {\n  return this.findOne({ email });\n});"
        },
        {
          name: "virtual()",
          category: "schema",
          type: "method",
          description: "T·∫°o virtual field. Fields kh√¥ng ƒë∆∞·ª£c l∆∞u trong database nh∆∞ng c√≥ th·ªÉ computed.",
          usage: "schema.virtual(name, options)",
          example: "userSchema.virtual('fullName').get(function() {\n  return this.firstName + ' ' + this.lastName;\n});"
        },
        {
          name: "virtualpath()",
          category: "schema",
          type: "method",
          description: "L·∫•y virtual path theo t√™n. Tr·∫£ v·ªÅ VirtualType instance.",
          usage: "schema.virtualpath(name)",
          example: "const fullNameVirtual = userSchema.virtualpath('fullName');\nconsole.log(fullNameVirtual.getters);"
        },
        {
          name: "virtuals",
          category: "schema",
          type: "property",
          description: "Object ch·ª©a t·∫•t c·∫£ virtual paths trong schema.",
          usage: "schema.virtuals",
          example: "console.log(Object.keys(userSchema.virtuals));\n// ['id', 'fullName']"
        },
        {
          name: "Schema.reserved",
          category: "schema",
          type: "static",
          description: "Object ch·ª©a c√°c t√™n path b·ªã reserved (kh√¥ng th·ªÉ s·ª≠ d·ª•ng).",
          usage: "Schema.reserved",
          example: "console.log(Schema.reserved);\n// { _posts: true, toObject: true, validate: true, ... }"
        }
      ],
      connection: [
        {
          name: "Connection()",
          category: "connection",
          type: "constructor",
          description: "Constructor ƒë·ªÉ t·∫°o connection instance m·ªõi. Qu·∫£n l√Ω k·∫øt n·ªëi t·ªõi MongoDB database.",
          usage: "new Connection(base)",
          example: "const conn = new mongoose.Connection(mongoose);\n// T·∫°o connection m·ªõi"
        },
        {
          name: "asPromise()",
          category: "connection",
          type: "method",
          description: "Tr·∫£ v·ªÅ Promise s·∫Ω resolve khi connection ƒë√£ s·∫µn s√†ng ho·∫∑c reject n·∫øu c√≥ l·ªói.",
          usage: "connection.asPromise()",
          example: "const conn = mongoose.createConnection();\nconn.asPromise().then(() => {\n  console.log('Connection ready!');\n});"
        },
        {
          name: "client",
          category: "connection",
          type: "property",
          description: "MongoDB client instance. Cung c·∫•p truy c·∫≠p t·ªõi native MongoDB driver client.",
          usage: "connection.client",
          example: "const client = mongoose.connection.client;\nconsole.log(client.topology.description);"
        },
        {
          name: "close()",
          category: "connection",
          type: "method",
          description: "ƒê√≥ng connection. Ng·∫Øt k·∫øt n·ªëi v√† gi·∫£i ph√≥ng t√†i nguy√™n.",
          usage: "connection.close(callback)",
          example: "await mongoose.connection.close();\nconsole.log('Connection closed');"
        },
        {
          name: "collection()",
          category: "connection",
          type: "method",
          description: "L·∫•y collection instance t·ª´ connection. Truy c·∫≠p tr·ª±c ti·∫øp t·ªõi MongoDB collection.",
          usage: "connection.collection(name, options)",
          example: "const users = mongoose.connection.collection('users');\nconst count = await users.countDocuments();"
        },
        {
          name: "collections",
          category: "connection",
          type: "property",
          description: "Object ch·ª©a t·∫•t c·∫£ collection instances ƒë√£ ƒë∆∞·ª£c t·∫°o t·ª´ connection n√†y.",
          usage: "connection.collections",
          example: "console.log(Object.keys(mongoose.connection.collections));\n// ['users', 'posts', 'comments']"
        },
        {
          name: "config",
          category: "connection",
          type: "property",
          description: "Object ch·ª©a c·∫•u h√¨nh connection. Bao g·ªìm c√°c settings v√† options.",
          usage: "connection.config",
          example: "console.log(mongoose.connection.config);\n// { autoIndex: true, bufferCommands: true, ... }"
        },
        {
          name: "createCollection()",
          category: "connection",
          type: "method",
          description: "T·∫°o collection m·ªõi trong database. S·ª≠ d·ª•ng native MongoDB createCollection.",
          usage: "connection.createCollection(name, options)",
          example: "await mongoose.connection.createCollection('logs', {\n  capped: true,\n  size: 1024 * 1024\n});"
        },
        {
          name: "db",
          category: "connection",
          type: "property",
          description: "MongoDB database instance. Cung c·∫•p truy c·∫≠p t·ªõi native MongoDB Db object.",
          usage: "connection.db",
          example: "const admin = mongoose.connection.db.admin();\nconst info = await admin.serverInfo();"
        },
        {
          name: "deleteModel()",
          category: "connection",
          type: "method",
          description: "X√≥a model kh·ªèi connection registry. H·ªØu √≠ch khi testing ho·∫∑c hot reloading.",
          usage: "connection.deleteModel(name)",
          example: "conn.deleteModel('User');\n// Model User b·ªã x√≥a kh·ªèi connection"
        },
        {
          name: "destroy()",
          category: "connection",
          type: "method",
          description: "Ph√° h·ªßy connection ho√†n to√†n. ƒê√≥ng connection v√† x√≥a t·∫•t c·∫£ listeners.",
          usage: "connection.destroy()",
          example: "await conn.destroy();\nconsole.log('Connection destroyed');"
        },
        {
          name: "dropCollection()",
          category: "connection",
          type: "method",
          description: "X√≥a collection kh·ªèi database. S·ª≠ d·ª•ng native MongoDB dropCollection.",
          usage: "connection.dropCollection(name, callback)",
          example: "await mongoose.connection.dropCollection('temp_data');\nconsole.log('Collection dropped');"
        },
        {
          name: "dropDatabase()",
          category: "connection",
          type: "method",
          description: "X√≥a to√†n b·ªô database. C·∫©n th·∫≠n khi s·ª≠ d·ª•ng - s·∫Ω x√≥a t·∫•t c·∫£ d·ªØ li·ªáu!",
          usage: "connection.dropDatabase(callback)",
          example: "// C·∫©n th·∫≠n! S·∫Ω x√≥a to√†n b·ªô database\n// await mongoose.connection.dropDatabase();"
        },
        {
          name: "get()",
          category: "connection",
          type: "method",
          description: "L·∫•y gi√° tr·ªã option c·ªßa connection. ƒê·ªçc c√°c thi·∫øt l·∫≠p c·∫•u h√¨nh.",
          usage: "connection.get(key)",
          example: "const bufferCommands = conn.get('bufferCommands');\nconsole.log('Buffer commands:', bufferCommands);"
        },
        {
          name: "getClient()",
          category: "connection",
          type: "method",
          description: "L·∫•y MongoDB client instance. Wrapper cho property client.",
          usage: "connection.getClient()",
          example: "const client = mongoose.connection.getClient();\nconsole.log('Client options:', client.options);"
        },
        {
          name: "host",
          category: "connection",
          type: "property",
          description: "Hostname c·ªßa MongoDB server. ƒê·ªçc t·ª´ connection string.",
          usage: "connection.host",
          example: "console.log('Connected to host:', mongoose.connection.host);\n// 'localhost' ho·∫∑c IP address"
        },
        {
          name: "id",
          category: "connection",
          type: "property",
          description: "Unique identifier c·ªßa connection. M·ªói connection c√≥ ID ri√™ng.",
          usage: "connection.id",
          example: "console.log('Connection ID:', mongoose.connection.id);\n// S·ªë unique ID"
        },
        {
          name: "model()",
          category: "connection",
          type: "method",
          description: "ƒê·ªãnh nghƒ©a ho·∫∑c l·∫•y model cho connection n√†y. T∆∞∆°ng t·ª± mongoose.model nh∆∞ng ch·ªâ cho connection c·ª• th·ªÉ.",
          usage: "connection.model(name, schema, collection)",
          example: "const User = conn.model('User', userSchema);\n// Model ch·ªâ thu·ªôc v·ªÅ connection n√†y"
        },
        {
          name: "modelNames()",
          category: "connection",
          type: "method",
          description: "Tr·∫£ v·ªÅ array ch·ª©a t√™n c·ªßa t·∫•t c·∫£ models ƒë√£ ƒëƒÉng k√Ω v·ªõi connection n√†y.",
          usage: "connection.modelNames()",
          example: "console.log('Models on this connection:', conn.modelNames());\n// ['User', 'Post']"
        },
        {
          name: "models",
          category: "connection",
          type: "property",
          description: "Object ch·ª©a t·∫•t c·∫£ models ƒë√£ ƒëƒÉng k√Ω v·ªõi connection n√†y.",
          usage: "connection.models",
          example: "console.log(Object.keys(conn.models));\n// ['User', 'Post', 'Comment']"
        },
        {
          name: "name",
          category: "connection",
          type: "property",
          description: "T√™n database m√† connection ƒëang k·∫øt n·ªëi t·ªõi.",
          usage: "connection.name",
          example: "console.log('Database name:', mongoose.connection.name);\n// 'myapp' ho·∫∑c t√™n database"
        },
        {
          name: "openUri()",
          category: "connection",
          type: "method",
          description: "M·ªü connection t·ªõi MongoDB URI. Method ch√≠nh ƒë·ªÉ k·∫øt n·ªëi database.",
          usage: "connection.openUri(uri, options)",
          example: "const conn = mongoose.createConnection();\nawait conn.openUri('mongodb://localhost/testdb');"
        },
        {
          name: "pass",
          category: "connection",
          type: "property",
          description: "Password ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ k·∫øt n·ªëi database (n·∫øu c√≥ authentication).",
          usage: "connection.pass",
          example: "console.log('Password set:', !!mongoose.connection.pass);\n// true/false"
        },
        {
          name: "plugin()",
          category: "connection",
          type: "method",
          description: "√Åp d·ª•ng plugin cho t·∫•t c·∫£ schemas trong connection n√†y.",
          usage: "connection.plugin(fn, options)",
          example: "conn.plugin(require('mongoose-timestamp'));\n// Plugin √°p d·ª•ng cho t·∫•t c·∫£ models trong connection"
        },
        {
          name: "plugins",
          category: "connection",
          type: "property",
          description: "Array ch·ª©a t·∫•t c·∫£ plugins ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng cho connection n√†y.",
          usage: "connection.plugins",
          example: "console.log('Applied plugins:', conn.plugins.length);\n// S·ªë l∆∞·ª£ng plugins"
        },
        {
          name: "port",
          category: "connection",
          type: "property",
          description: "Port number c·ªßa MongoDB server. M·∫∑c ƒë·ªãnh l√† 27017.",
          usage: "connection.port",
          example: "console.log('Connected to port:', mongoose.connection.port);\n// 27017"
        },
        {
          name: "readyState",
          category: "connection",
          type: "property",
          description: "Tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa connection: 0=disconnected, 1=connected, 2=connecting, 3=disconnecting.",
          usage: "connection.readyState",
          example: "if (mongoose.connection.readyState === 1) {\n  console.log('Connected!');\n}"
        },
        {
          name: "set()",
          category: "connection",
          type: "method",
          description: "Thi·∫øt l·∫≠p option cho connection. C·∫•u h√¨nh c√°c thi·∫øt l·∫≠p ri√™ng cho connection.",
          usage: "connection.set(key, value)",
          example: "conn.set('bufferCommands', false);\nconn.set('debug', true);"
        },
        {
          name: "setClient()",
          category: "connection",
          type: "method",
          description: "Thi·∫øt l·∫≠p MongoDB client cho connection. S·ª≠ d·ª•ng client c√≥ s·∫µn.",
          usage: "connection.setClient(client)",
          example: "const { MongoClient } = require('mongodb');\nconst client = new MongoClient(uri);\nconn.setClient(client);"
        },
        {
          name: "startSession()",
          category: "connection",
          type: "method",
          description: "B·∫Øt ƒë·∫ßu client session m·ªõi cho connection n√†y. H·ªó tr·ª£ transactions.",
          usage: "connection.startSession(options)",
          example: "const session = await conn.startSession();\nawait session.startTransaction();"
        },
        {
          name: "syncIndexes",
          category: "connection",
          type: "property",
          description: "Boolean option ƒë·ªÉ ƒë·ªìng b·ªô h√≥a indexes t·ª± ƒë·ªông khi models ƒë∆∞·ª£c compile.",
          usage: "connection.syncIndexes",
          example: "conn.syncIndexes = true;\n// Auto sync indexes when models compile"
        },
        {
          name: "transaction()",
          category: "connection",
          type: "method",
          description: "Ch·∫°y function trong transaction. Wrapper ti·ªán l·ª£i cho transactions.",
          usage: "connection.transaction(fn, options)",
          example: "await conn.transaction(async (session) => {\n  await User.create([{name: 'John'}], {session});\n  await Post.create([{title: 'Hello'}], {session});\n});"
        },
        {
          name: "useDb()",
          category: "connection",
          type: "method",
          description: "Chuy·ªÉn ƒë·ªïi sang database kh√°c tr√™n c√πng connection. T·∫°o connection m·ªõi cho database kh√°c.",
          usage: "connection.useDb(name, options)",
          example: "const logsDb = conn.useDb('logs');\nconst LogModel = logsDb.model('Log', logSchema);"
        },
        {
          name: "user",
          category: "connection",
          type: "property",
          description: "Username ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ k·∫øt n·ªëi database (n·∫øu c√≥ authentication).",
          usage: "connection.user",
          example: "console.log('Connected as user:', mongoose.connection.user);\n// username ho·∫∑c undefined"
        },
        {
          name: "watch()",
          category: "connection",
          type: "method",
          description: "T·∫°o change stream ƒë·ªÉ theo d√µi thay ƒë·ªïi tr√™n to√†n database. MongoDB 3.6+.",
          usage: "connection.watch(pipeline, options)",
          example: "const changeStream = mongoose.connection.watch();\nchangeStream.on('change', (change) => {\n  console.log('Database changed:', change);\n});"
        }
      ],// Document API Data - Th√™m v√†o object apiData trong HTML
      document: [
        {
          name: "$assertPopulated()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra v√† ƒë·∫£m b·∫£o r·∫±ng path ƒë√£ ƒë∆∞·ª£c populate. N√©m l·ªói n·∫øu path ch∆∞a ƒë∆∞·ª£c populate.",
          usage: "doc.$assertPopulated(path, values)",
          example: "user.$assertPopulated('posts');\n// ƒê·∫£m b·∫£o posts ƒë√£ ƒë∆∞·ª£c populate"
        },
        {
          name: "$clone()",
          category: "document",
          type: "method",
          description: "T·∫°o b·∫£n sao c·ªßa document. Clone to√†n b·ªô document v·ªõi t·∫•t c·∫£ properties.",
          usage: "doc.$clone()",
          example: "const userCopy = user.$clone();\nuserCopy.name = 'New Name';\n// user g·ªëc kh√¥ng b·ªã thay ƒë·ªïi"
        },
        {
          name: "$errors",
          category: "document",
          type: "property",
          description: "Object ch·ª©a validation errors c·ªßa document. Null n·∫øu kh√¥ng c√≥ l·ªói.",
          usage: "doc.$errors",
          example: "if (user.$errors) {\n  console.log('Validation errors:', user.$errors);\n}"
        },
        {
          name: "$getAllSubdocs()",
          category: "document",
          type: "method",
          description: "L·∫•y t·∫•t c·∫£ subdocuments trong document. Bao g·ªìm c·∫£ nested subdocuments.",
          usage: "doc.$getAllSubdocs()",
          example: "const subdocs = user.$getAllSubdocs();\nconsole.log('Found subdocuments:', subdocs.length);"
        },
        {
          name: "$getPopulatedDocs()",
          category: "document",
          type: "method",
          description: "L·∫•y t·∫•t c·∫£ documents ƒë√£ ƒë∆∞·ª£c populate. Tr·∫£ v·ªÅ array c√°c populated documents.",
          usage: "doc.$getPopulatedDocs()",
          example: "const populated = user.$getPopulatedDocs();\nconsole.log('Populated docs:', populated);"
        },
        {
          name: "$ignore()",
          category: "document",
          type: "method",
          description: "B·ªè qua path kh·ªèi validation v√† save operations. Path s·∫Ω kh√¥ng ƒë∆∞·ª£c x·ª≠ l√Ω.",
          usage: "doc.$ignore(path)",
          example: "user.$ignore('temporaryField');\n// temporaryField s·∫Ω kh√¥ng ƒë∆∞·ª£c save"
        },
        {
          name: "$inc()",
          category: "document",
          type: "method",
          description: "TƒÉng gi√° tr·ªã numeric field. S·ª≠ d·ª•ng $inc operator c·ªßa MongoDB.",
          usage: "doc.$inc(path, val)",
          example: "user.$inc('loginCount', 1);\n// TƒÉng loginCount l√™n 1"
        },
        {
          name: "$init()",
          category: "document",
          type: "method",
          description: "Kh·ªüi t·∫°o document v·ªõi data t·ª´ MongoDB. Internal method ƒë·ªÉ setup document.",
          usage: "doc.$init(obj, opts)",
          example: "// Internal method, th∆∞·ªùng kh√¥ng g·ªçi tr·ª±c ti·∫øp\ndoc.$init(dataFromDB);"
        },
        {
          name: "$isDefault()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra xem path c√≥ ƒëang s·ª≠ d·ª•ng gi√° tr·ªã default kh√¥ng.",
          usage: "doc.$isDefault(path)",
          example: "if (user.$isDefault('status')) {\n  console.log('Status is using default value');\n}"
        },
        {
          name: "$isDeleted()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra xem document c√≥ b·ªã ƒë√°nh d·∫•u l√† deleted kh√¥ng (soft delete).",
          usage: "doc.$isDeleted()",
          example: "if (user.$isDeleted()) {\n  console.log('User is soft deleted');\n}"
        },
        {
          name: "$isEmpty()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra xem path c√≥ empty kh√¥ng. √Åp d·ª•ng cho arrays, objects, strings.",
          usage: "doc.$isEmpty(path)",
          example: "if (user.$isEmpty('tags')) {\n  console.log('Tags array is empty');\n}"
        },
        {
          name: "$isModified()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra xem path c√≥ b·ªã modified kh√¥ng. T∆∞∆°ng t·ª± isModified nh∆∞ng internal.",
          usage: "doc.$isModified(path)",
          example: "if (user.$isModified('email')) {\n  console.log('Email has been changed');\n}"
        },
        {
          name: "$isNew",
          category: "document",
          type: "property",
          description: "Boolean cho bi·∫øt document c√≥ ph·∫£i l√† new (ch∆∞a save) kh√¥ng.",
          usage: "doc.$isNew",
          example: "if (user.$isNew) {\n  console.log('This is a new user');\n}"
        },
        {
          name: "$locals",
          category: "document",
          type: "property",
          description: "Object ƒë·ªÉ l∆∞u tr·ªØ local data t·∫°m th·ªùi. Kh√¥ng ƒë∆∞·ª£c save v√†o database.",
          usage: "doc.$locals",
          example: "user.$locals.tempData = 'some value';\n// Ch·ªâ t·ªìn t·∫°i trong memory"
        },
        {
          name: "$markValid()",
          category: "document",
          type: "method",
          description: "ƒê√°nh d·∫•u path l√† valid, x√≥a validation errors cho path ƒë√≥.",
          usage: "doc.$markValid(path)",
          example: "user.$markValid('email');\n// X√≥a l·ªói validation cho email"
        },
        {
          name: "$op",
          category: "document",
          type: "property",
          description: "Operation hi·ªán t·∫°i ƒëang ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n document (save, remove, etc).",
          usage: "doc.$op",
          example: "console.log('Current operation:', user.$op);\n// 'save', 'remove', null"
        },
        {
          name: "$parent()",
          category: "document",
          type: "method",
          description: "L·∫•y parent document n·∫øu ƒë√¢y l√† subdocument.",
          usage: "doc.$parent()",
          example: "const parent = address.$parent();\n// L·∫•y user ch·ª©a address subdocument"
        },
        {
          name: "$populated()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra xem path c√≥ ƒë∆∞·ª£c populate kh√¥ng v√† tr·∫£ v·ªÅ populate options.",
          usage: "doc.$populated(path)",
          example: "const populateInfo = user.$populated('posts');\nif (populateInfo) {\n  console.log('Posts were populated');\n}"
        },
        {
          name: "$session()",
          category: "document",
          type: "method",
          description: "L·∫•y ho·∫∑c thi·∫øt l·∫≠p session cho document operations.",
          usage: "doc.$session(session)",
          example: "const session = await mongoose.startSession();\nuser.$session(session);\nawait user.save();"
        },
        {
          name: "$set()",
          category: "document",
          type: "method",
          description: "Thi·∫øt l·∫≠p gi√° tr·ªã cho path. T∆∞∆°ng t·ª± set() nh∆∞ng c√≥ th√™m options.",
          usage: "doc.$set(path, val, type, options)",
          example: "user.$set('name', 'John Doe');\nuser.$set({ age: 30, city: 'NYC' });"
        },
        {
          name: "$timestamps()",
          category: "document",
          type: "method",
          description: "C·∫≠p nh·∫≠t timestamps (createdAt, updatedAt) cho document.",
          usage: "doc.$timestamps()",
          example: "user.$timestamps();\n// C·∫≠p nh·∫≠t updatedAt = new Date()"
        },
        {
          name: "$validate()",
          category: "document",
          type: "method",
          description: "Validate document v√† tr·∫£ v·ªÅ Promise. Internal validation method.",
          usage: "doc.$validate(pathsToValidate, options)",
          example: "await user.$validate(['email', 'name']);\n// Validate specific paths"
        },
        {
          name: "$where",
          category: "document",
          type: "property",
          description: "Object ch·ª©a query conditions s·ª≠ d·ª•ng $where operator.",
          usage: "doc.$where",
          example: "// Ch·ªß y·∫øu d√πng internal\nconsole.log(user.$where);"
        },
        {
          name: "depopulate()",
          category: "document",
          type: "method",
          description: "Lo·∫°i b·ªè populated values, tr·∫£ v·ªÅ ObjectIds ban ƒë·∫ßu.",
          usage: "doc.depopulate(path)",
          example: "user.depopulate('posts');\n// posts tr·ªü v·ªÅ array ObjectIds"
        },
        {
          name: "directModifiedPaths()",
          category: "document",
          type: "method",
          description: "L·∫•y array c√°c paths ƒë√£ ƒë∆∞·ª£c modify tr·ª±c ti·∫øp (kh√¥ng bao g·ªìm nested).",
          usage: "doc.directModifiedPaths()",
          example: "const modified = user.directModifiedPaths();\nconsole.log('Direct modified:', modified);"
        },
        {
          name: "equals()",
          category: "document",
          type: "method",
          description: "So s√°nh document n√†y v·ªõi document kh√°c. So s√°nh theo _id.",
          usage: "doc.equals(other)",
          example: "if (user1.equals(user2)) {\n  console.log('Same user');\n}"
        },
        {
          name: "errors",
          category: "document",
          type: "property",
          description: "Object ch·ª©a validation errors sau khi validate. Null n·∫øu kh√¥ng c√≥ l·ªói.",
          usage: "doc.errors",
          example: "if (user.errors) {\n  console.log('Validation failed:', user.errors);\n}"
        },
        {
          name: "get()",
          category: "document",
          type: "method",
          description: "L·∫•y gi√° tr·ªã c·ªßa path. C√≥ th·ªÉ l·∫•y nested paths b·∫±ng dot notation.",
          usage: "doc.get(path, type, options)",
          example: "const name = user.get('name');\nconst city = user.get('address.city');"
        },
        {
          name: "getChanges()",
          category: "document",
          type: "method",
          description: "L·∫•y object ch·ª©a t·∫•t c·∫£ thay ƒë·ªïi s·∫Ω ƒë∆∞·ª£c √°p d·ª•ng khi save.",
          usage: "doc.getChanges()",
          example: "const changes = user.getChanges();\nconsole.log('Will update:', changes);"
        },
        {
          name: "id",
          category: "document",
          type: "property",
          description: "Virtual getter cho _id field. Tr·∫£ v·ªÅ string representation c·ªßa _id.",
          usage: "doc.id",
          example: "console.log('User ID:', user.id);\n// String version c·ªßa ObjectId"
        },
        {
          name: "init()",
          category: "document",
          type: "method",
          description: "Kh·ªüi t·∫°o document v·ªõi data. ƒê√°nh d·∫•u t·∫•t c·∫£ fields l√† unmodified.",
          usage: "doc.init(obj, opts)",
          example: "user.init({ name: 'John', age: 30 });\n// Kh·ªüi t·∫°o document state"
        },
        {
          name: "inspect()",
          category: "document",
          type: "method",
          description: "Tr·∫£ v·ªÅ string representation ƒë·ªÉ debugging. S·ª≠ d·ª•ng trong console.log.",
          usage: "doc.inspect()",
          example: "console.log(user.inspect());\n// Pretty formatted output"
        },
        {
          name: "invalidate()",
          category: "document",
          type: "method",
          description: "ƒê√°nh d·∫•u path l√† invalid v·ªõi error message. T·∫°o validation error.",
          usage: "doc.invalidate(path, errorMsg, value, kind)",
          example: "user.invalidate('email', 'Email is required');\n// T·∫°o validation error"
        },
        {
          name: "isDirectModified()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra path c√≥ ƒë∆∞·ª£c modify tr·ª±c ti·∫øp kh√¥ng (kh√¥ng qua subdocument).",
          usage: "doc.isDirectModified(path)",
          example: "if (user.isDirectModified('name')) {\n  console.log('Name was changed directly');\n}"
        },
        {
          name: "isDirectSelected()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra path c√≥ ƒë∆∞·ª£c select tr·ª±c ti·∫øp trong query kh√¥ng.",
          usage: "doc.isDirectSelected(path)",
          example: "if (user.isDirectSelected('email')) {\n  console.log('Email was explicitly selected');\n}"
        },
        {
          name: "isInit()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra path ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ch∆∞a.",
          usage: "doc.isInit(path)",
          example: "if (user.isInit('profile')) {\n  console.log('Profile has been initialized');\n}"
        },
        {
          name: "isModified()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra path c√≥ b·ªã thay ƒë·ªïi kh√¥ng. C√≥ th·ªÉ check nhi·ªÅu paths.",
          usage: "doc.isModified(path)",
          example: "if (user.isModified('email')) {\n  console.log('Email has been modified');\n}\nif (user.isModified(['name', 'age'])) {\n  console.log('Name or age modified');\n}"
        },
        {
          name: "isNew",
          category: "document",
          type: "property",
          description: "Boolean cho bi·∫øt document c√≥ ph·∫£i l√† m·ªõi (ch∆∞a ƒë∆∞·ª£c save l·∫ßn n√†o).",
          usage: "doc.isNew",
          example: "if (user.isNew) {\n  console.log('This user has never been saved');\n}"
        },
        {
          name: "isSelected()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra path c√≥ ƒë∆∞·ª£c include trong query select kh√¥ng.",
          usage: "doc.isSelected(path)",
          example: "if (user.isSelected('email')) {\n  console.log('Email was included in select');\n}"
        },
        {
          name: "markModified()",
          category: "document",
          type: "method",
          description: "ƒê√°nh d·∫•u path l√† ƒë√£ modified. H·ªØu √≠ch khi modify nested objects.",
          usage: "doc.markModified(path, scope)",
          example: "user.profile.preferences.theme = 'dark';\nuser.markModified('profile.preferences');\n// ƒê·∫£m b·∫£o nested change ƒë∆∞·ª£c save"
        },
        {
          name: "modifiedPaths()",
          category: "document",
          type: "method",
          description: "L·∫•y array t·∫•t c·∫£ paths ƒë√£ ƒë∆∞·ª£c modify, bao g·ªìm c·∫£ nested paths.",
          usage: "doc.modifiedPaths(includeChildren)",
          example: "const modified = user.modifiedPaths();\nconsole.log('Modified paths:', modified);\n// ['name', 'profile.bio']"
        },
        {
          name: "overwrite()",
          category: "document",
          type: "method",
          description: "Ghi ƒë√® to√†n b·ªô document v·ªõi object m·ªõi. Thay th·∫ø t·∫•t c·∫£ fields.",
          usage: "doc.overwrite(obj)",
          example: "user.overwrite({ name: 'John', age: 25 });\n// T·∫•t c·∫£ fields kh√°c b·ªã x√≥a"
        },
        {
          name: "parent()",
          category: "document",
          type: "method",
          description: "L·∫•y parent document n·∫øu ƒë√¢y l√† subdocument.",
          usage: "doc.parent()",
          example: "const parent = comment.parent();\n// L·∫•y post ch·ª©a comment n√†y"
        },
        {
          name: "populate()",
          category: "document",
          type: "method",
          description: "Populate references trong document. Load d·ªØ li·ªáu t·ª´ collections kh√°c.",
          usage: "doc.populate(path, select, model, match, options)",
          example: "await user.populate('posts');\nawait user.populate({\n  path: 'posts',\n  select: 'title content',\n  match: { published: true }\n});"
        },
        {
          name: "populated()",
          category: "document",
          type: "method",
          description: "Ki·ªÉm tra path ƒë√£ ƒë∆∞·ª£c populate ch∆∞a v√† tr·∫£ v·ªÅ populated value.",
          usage: "doc.populated(path)",
          example: "const posts = user.populated('posts');\nif (posts) {\n  console.log('Posts are populated');\n}"
        },
        {
          name: "replaceOne()",
          category: "document",
          type: "method",
          description: "Thay th·∫ø document trong database v·ªõi document hi·ªán t·∫°i.",
          usage: "doc.replaceOne(replacement, options)",
          example: "await user.replaceOne({ name: 'New Name', age: 30 });\n// Thay th·∫ø to√†n b·ªô document"
        },
        {
          name: "save()",
          category: "document",
          type: "method",
          description: "L∆∞u document v√†o database. T·∫°o m·ªõi n·∫øu isNew, update n·∫øu ƒë√£ t·ªìn t·∫°i.",
          usage: "doc.save(options)",
          example: "await user.save();\n// Ho·∫∑c v·ªõi options\nawait user.save({ validateBeforeSave: false });"
        },
        {
          name: "schema",
          category: "document",
          type: "property",
          description: "Reference t·ªõi Schema instance m√† document n√†y d·ª±a tr√™n.",
          usage: "doc.schema",
          example: "console.log('Schema paths:', Object.keys(user.schema.paths));\nconst nameType = user.schema.path('name');"
        },
        {
          name: "set()",
          category: "document",
          type: "method",
          description: "Thi·∫øt l·∫≠p gi√° tr·ªã cho path. C√≥ th·ªÉ set nhi·ªÅu paths c√πng l√∫c.",
          usage: "doc.set(path, val, type, options)",
          example: "user.set('name', 'John Doe');\nuser.set({\n  age: 30,\n  'profile.bio': 'Software Developer'\n});"
        },
        {
          name: "toJSON()",
          category: "document",
          type: "method",
          description: "Chuy·ªÉn document th√†nh JSON object. √Åp d·ª•ng transform v√† virtuals.",
          usage: "doc.toJSON(options)",
          example: "const json = user.toJSON();\nconsole.log(json);\n// Ho·∫∑c v·ªõi options\nconst json = user.toJSON({ virtuals: true });"
        },
        {
          name: "toObject()",
          category: "document",
          type: "method",
          description: "Chuy·ªÉn document th√†nh plain JavaScript object. C√≥ nhi·ªÅu options.",
          usage: "doc.toObject(options)",
          example: "const obj = user.toObject();\n// Ho·∫∑c v·ªõi options\nconst obj = user.toObject({\n  transform: true,\n  virtuals: true\n});"
        },
        {
          name: "toString()",
          category: "document",
          type: "method",
          description: "Tr·∫£ v·ªÅ string representation c·ªßa document. Th∆∞·ªùng l√† ObjectId.",
          usage: "doc.toString()",
          example: "console.log(user.toString());\n// ObjectId string representation"
        },
        {
          name: "unmarkModified()",
          category: "document",
          type: "method",
          description: "B·ªè ƒë√°nh d·∫•u modified cho path. Path s·∫Ω kh√¥ng ƒë∆∞·ª£c save trong l·∫ßn save ti·∫øp theo.",
          usage: "doc.unmarkModified(path)",
          example: "user.name = 'New Name';\nuser.unmarkModified('name');\n// name s·∫Ω kh√¥ng ƒë∆∞·ª£c save"
        },
        {
          name: "update()",
          category: "document",
          type: "method",
          description: "Update document trong database m√† kh√¥ng load v·ªÅ memory. Deprecated - d√πng updateOne.",
          usage: "doc.update(update, options)",
          example: "// Deprecated - s·ª≠ d·ª•ng updateOne thay th·∫ø\n// await user.update({ $set: { age: 30 } });"
        },
        {
          name: "updateOne()",
          category: "document",
          type: "method",
          description: "Update document trong database v·ªõi update operators.",
          usage: "doc.updateOne(update, options)",
          example: "await user.updateOne({ $set: { age: 30 } });\nawait user.updateOne({ $inc: { loginCount: 1 } });"
        },
        {
          name: "validate()",
          category: "document",
          type: "method",
          description: "Validate document theo schema rules. Tr·∫£ v·ªÅ Promise.",
          usage: "doc.validate(pathsToValidate, options)",
          example: "try {\n  await user.validate();\n  console.log('Validation passed');\n} catch (error) {\n  console.log('Validation failed:', error);\n}"
        },
        {
          name: "validateSync()",
          category: "document",
          type: "method",
          description: "Validate document ƒë·ªìng b·ªô. Tr·∫£ v·ªÅ validation error ho·∫∑c undefined.",
          usage: "doc.validateSync(pathsToValidate, options)",
          example: "const error = user.validateSync();\nif (error) {\n  console.log('Validation failed:', error);\n} else {\n  console.log('Validation passed');\n}"
        }
      ], model: [
        {
          name: "Model()",
          category: "model",
          type: "constructor",
          description: "Constructor ƒë·ªÉ t·∫°o Model instance. Base class cho t·∫•t c·∫£ Mongoose models.",
          usage: "new Model(doc, fields, skipId)",
          example: "const user = new User({ name: 'John', age: 30 });\n// T·∫°o document instance t·ª´ model"
        },
        {
          name: "$where()",
          category: "model",
          type: "static",
          description: "T·∫°o query s·ª≠ d·ª•ng JavaScript expression. Cho ph√©p logic ph·ª©c t·∫°p trong query.",
          usage: "Model.$where(js)",
          example: "const users = await User.$where('this.age > 18');\n// S·ª≠ d·ª•ng JavaScript trong query"
        },
        {
          name: "aggregate()",
          category: "model",
          type: "static",
          description: "T·∫°o aggregation pipeline. Th·ª±c hi·ªán c√°c operations ph·ª©c t·∫°p nh∆∞ group, match, sort.",
          usage: "Model.aggregate(pipeline, options)",
          example: "const result = await User.aggregate([\n  { $match: { age: { $gte: 18 } } },\n  { $group: { _id: '$department', count: { $sum: 1 } } }\n]);"
        },
        {
          name: "applyDefaults()",
          category: "model",
          type: "static",
          description: "√Åp d·ª•ng gi√° tr·ªã default cho document object. Kh√¥ng t·∫°o Model instance.",
          usage: "Model.applyDefaults(doc)",
          example: "const doc = { name: 'John' };\nUser.applyDefaults(doc);\n// doc s·∫Ω c√≥ c√°c default values"
        },
        {
          name: "bulkSave",
          category: "model",
          type: "static",
          description: "L∆∞u nhi·ªÅu documents c√πng l√∫c v·ªõi validation. Hi·ªáu qu·∫£ h∆°n save t·ª´ng c√°i.",
          usage: "Model.bulkSave(docs, options)",
          example: "const users = [new User({name: 'A'}), new User({name: 'B'})];\nawait User.bulkSave(users);"
        },
        {
          name: "bulkWrite()",
          category: "model",
          type: "static",
          description: "Th·ª±c hi·ªán nhi·ªÅu write operations c√πng l√∫c. H·ªó tr·ª£ insert, update, delete.",
          usage: "Model.bulkWrite(operations, options)",
          example: "await User.bulkWrite([\n  { insertOne: { document: { name: 'John' } } },\n  { updateOne: { filter: { name: 'Jane' }, update: { age: 25 } } },\n  { deleteOne: { filter: { name: 'Bob' } } }\n]);"
        },
        {
          name: "castObject()",
          category: "model",
          type: "static",
          description: "Cast object theo schema c·ªßa model. Chuy·ªÉn ƒë·ªïi ki·ªÉu d·ªØ li·ªáu v√† validate.",
          usage: "Model.castObject(obj, options)",
          example: "const casted = User.castObject({\n  age: '25', // string -> number\n  active: 'true' // string -> boolean\n});"
        },
        {
          name: "cleanIndexes()",
          category: "model",
          type: "static",
          description: "X√≥a c√°c indexes kh√¥ng c√≤n ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong schema.",
          usage: "Model.cleanIndexes()",
          example: "await User.cleanIndexes();\n// X√≥a indexes c≈© kh√¥ng c·∫ßn thi·∫øt"
        },
        {
          name: "count()",
          category: "model",
          type: "static",
          description: "ƒê·∫øm s·ªë documents match query. Deprecated - s·ª≠ d·ª•ng countDocuments().",
          usage: "Model.count(filter, callback)",
          example: "// Deprecated - s·ª≠ d·ª•ng countDocuments\n// const count = await User.count({ active: true });"
        },
        {
          name: "countDocuments()",
          category: "model",
          type: "static",
          description: "ƒê·∫øm s·ªë documents match query. Thay th·∫ø cho count().",
          usage: "Model.countDocuments(filter, options)",
          example: "const activeUsers = await User.countDocuments({ active: true });\nconst totalUsers = await User.countDocuments();"
        },
        {
          name: "create()",
          category: "model",
          type: "static",
          description: "T·∫°o v√† l∆∞u documents m·ªõi. Shortcut cho new Model().save().",
          usage: "Model.create(docs, options)",
          example: "const user = await User.create({ name: 'John', age: 30 });\n// Ho·∫∑c nhi·ªÅu documents\nconst users = await User.create([\n  { name: 'John' },\n  { name: 'Jane' }\n]);"
        },
        {
          name: "createCollection()",
          category: "model",
          type: "static",
          description: "T·∫°o MongoDB collection cho model v·ªõi options c·ª• th·ªÉ.",
          usage: "Model.createCollection(options)",
          example: "await User.createCollection({\n  capped: true,\n  size: 1024 * 1024\n});"
        },
        {
          name: "createIndexes()",
          category: "model",
          type: "static",
          description: "T·∫°o t·∫•t c·∫£ indexes ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong schema.",
          usage: "Model.createIndexes(options)",
          example: "await User.createIndexes();\n// T·∫°o t·∫•t c·∫£ indexes cho User model"
        },
        {
          name: "db",
          category: "model",
          type: "static",
          description: "Database instance m√† model n√†y thu·ªôc v·ªÅ.",
          usage: "Model.db",
          example: "console.log('Database name:', User.db.name);\nconst collections = await User.db.listCollections();"
        },
        {
          name: "deleteMany()",
          category: "model",
          type: "static",
          description: "X√≥a nhi·ªÅu documents match ƒëi·ªÅu ki·ªán. Kh√¥ng trigger middleware.",
          usage: "Model.deleteMany(conditions, options)",
          example: "const result = await User.deleteMany({ active: false });\nconsole.log('Deleted:', result.deletedCount);"
        },
        {
          name: "deleteOne()",
          category: "model",
          type: "static",
          description: "X√≥a m·ªôt document ƒë·∫ßu ti√™n match ƒëi·ªÅu ki·ªán. Kh√¥ng trigger middleware.",
          usage: "Model.deleteOne(conditions, options)",
          example: "const result = await User.deleteOne({ name: 'John' });\nconsole.log('Deleted:', result.deletedCount);"
        },
        {
          name: "diffIndexes()",
          category: "model",
          type: "static",
          description: "So s√°nh indexes hi·ªán t·∫°i v·ªõi indexes ƒë·ªãnh nghƒ©a trong schema.",
          usage: "Model.diffIndexes()",
          example: "const diff = await User.diffIndexes();\nconsole.log('Missing indexes:', diff.toDrop);\nconsole.log('New indexes:', diff.toCreate);"
        },
        {
          name: "discriminator()",
          category: "model",
          type: "static",
          description: "T·∫°o discriminator model. Inheritance pattern trong MongoDB.",
          usage: "Model.discriminator(name, schema, value)",
          example: "const Employee = User.discriminator('Employee', \n  new mongoose.Schema({ department: String })\n);"
        },
        {
          name: "distinct()",
          category: "model",
          type: "static",
          description: "L·∫•y c√°c gi√° tr·ªã unique c·ªßa field. Tr·∫£ v·ªÅ array c√°c gi√° tr·ªã kh√°c nhau.",
          usage: "Model.distinct(field, conditions)",
          example: "const departments = await User.distinct('department');\nconst activeDepts = await User.distinct('department', { active: true });"
        },
        {
          name: "ensureIndexes()",
          category: "model",
          type: "static",
          description: "ƒê·∫£m b·∫£o t·∫•t c·∫£ indexes ƒë∆∞·ª£c t·∫°o. Deprecated - s·ª≠ d·ª•ng createIndexes().",
          usage: "Model.ensureIndexes(options)",
          example: "// Deprecated - s·ª≠ d·ª•ng createIndexes\n// await User.ensureIndexes();"
        },
        {
          name: "estimatedDocumentCount()",
          category: "model",
          type: "static",
          description: "∆Ø·ªõc t√≠nh s·ªë documents trong collection. Nhanh h∆°n countDocuments nh∆∞ng kh√¥ng ch√≠nh x√°c.",
          usage: "Model.estimatedDocumentCount(options)",
          example: "const estimate = await User.estimatedDocumentCount();\nconsole.log('Estimated users:', estimate);"
        },
        {
          name: "events",
          category: "model",
          type: "static",
          description: "EventEmitter ƒë·ªÉ l·∫Øng nghe events t·ª´ model. H·ªó tr·ª£ index events.",
          usage: "Model.events",
          example: "User.events.on('index', (err) => {\n  if (err) console.error('Index error:', err);\n  else console.log('Index created successfully');\n});"
        },
        {
          name: "exists()",
          category: "model",
          type: "static",
          description: "Ki·ªÉm tra document c√≥ t·ªìn t·∫°i kh√¥ng. Tr·∫£ v·ªÅ _id n·∫øu t·ªìn t·∫°i, null n·∫øu kh√¥ng.",
          usage: "Model.exists(filter)",
          example: "const exists = await User.exists({ email: 'john@example.com' });\nif (exists) {\n  console.log('User exists with ID:', exists._id);\n}"
        },
        {
          name: "find()",
          category: "model",
          type: "static",
          description: "T√¨m documents match ƒëi·ªÅu ki·ªán. Tr·∫£ v·ªÅ array documents ho·∫∑c Query object.",
          usage: "Model.find(filter, projection, options)",
          example: "const users = await User.find({ active: true });\nconst names = await User.find({}, 'name email');\nconst query = User.find({ age: { $gte: 18 } });"
        },
        {
          name: "findById()",
          category: "model",
          type: "static",
          description: "T√¨m document theo _id. Shortcut cho findOne({ _id: id }).",
          usage: "Model.findById(id, projection, options)",
          example: "const user = await User.findById('507f1f77bcf86cd799439011');\nconst userBasic = await User.findById(id, 'name email');"
        },
        {
          name: "findByIdAndDelete()",
          category: "model",
          type: "static",
          description: "T√¨m v√† x√≥a document theo _id. Tr·∫£ v·ªÅ document ƒë√£ x√≥a.",
          usage: "Model.findByIdAndDelete(id, options)",
          example: "const deletedUser = await User.findByIdAndDelete(userId);\nif (deletedUser) {\n  console.log('Deleted user:', deletedUser.name);\n}"
        },
        {
          name: "findByIdAndRemove()",
          category: "model",
          type: "static",
          description: "T√¨m v√† x√≥a document theo _id. Deprecated - s·ª≠ d·ª•ng findByIdAndDelete().",
          usage: "Model.findByIdAndRemove(id, options)",
          example: "// Deprecated - s·ª≠ d·ª•ng findByIdAndDelete\n// const user = await User.findByIdAndRemove(id);"
        },
        {
          name: "findByIdAndUpdate()",
          category: "model",
          type: "static",
          description: "T√¨m v√† update document theo _id. Tr·∫£ v·ªÅ document c≈© ho·∫∑c m·ªõi.",
          usage: "Model.findByIdAndUpdate(id, update, options)",
          example: "const updatedUser = await User.findByIdAndUpdate(\n  userId,\n  { $set: { age: 30 } },\n  { new: true } // Tr·∫£ v·ªÅ document sau update\n);"
        },
        {
          name: "findOne()",
          category: "model",
          type: "static",
          description: "T√¨m m·ªôt document ƒë·∫ßu ti√™n match ƒëi·ªÅu ki·ªán. Tr·∫£ v·ªÅ document ho·∫∑c null.",
          usage: "Model.findOne(filter, projection, options)",
          example: "const user = await User.findOne({ email: 'john@example.com' });\nconst admin = await User.findOne({ role: 'admin' }, 'name email');"
        },
        {
          name: "findOneAndDelete()",
          category: "model",
          type: "static",
          description: "T√¨m v√† x√≥a m·ªôt document. Tr·∫£ v·ªÅ document ƒë√£ x√≥a.",
          usage: "Model.findOneAndDelete(conditions, options)",
          example: "const deletedUser = await User.findOneAndDelete(\n  { email: 'john@example.com' }\n);"
        },
        {
          name: "findOneAndRemove()",
          category: "model",
          type: "static",
          description: "T√¨m v√† x√≥a m·ªôt document. Deprecated - s·ª≠ d·ª•ng findOneAndDelete().",
          usage: "Model.findOneAndRemove(conditions, options)",
          example: "// Deprecated - s·ª≠ d·ª•ng findOneAndDelete\n// const user = await User.findOneAndRemove({ name: 'John' });"
        },
        {
          name: "findOneAndReplace()",
          category: "model",
          type: "static",
          description: "T√¨m v√† thay th·∫ø to√†n b·ªô document. Thay th·∫ø t·∫•t c·∫£ fields.",
          usage: "Model.findOneAndReplace(filter, replacement, options)",
          example: "const newUser = await User.findOneAndReplace(\n  { name: 'John' },\n  { name: 'John Doe', age: 30, email: 'john@example.com' },\n  { new: true }\n);"
        },
        {
          name: "findOneAndUpdate()",
          category: "model",
          type: "static",
          description: "T√¨m v√† update m·ªôt document. Tr·∫£ v·ªÅ document c≈© ho·∫∑c m·ªõi.",
          usage: "Model.findOneAndUpdate(filter, update, options)",
          example: "const user = await User.findOneAndUpdate(\n  { email: 'john@example.com' },\n  { $inc: { loginCount: 1 } },\n  { new: true, upsert: true }\n);"
        },
        {
          name: "hydrate()",
          category: "model",
          type: "static",
          description: "T·∫°o Mongoose document t·ª´ plain object m√† kh√¥ng init t·ª´ MongoDB.",
          usage: "Model.hydrate(obj, projection)",
          example: "const user = User.hydrate({\n  _id: '507f1f77bcf86cd799439011',\n  name: 'John',\n  age: 30\n});\n// Document ƒë√£ hydrated, kh√¥ng ph·∫£i isNew"
        },
        {
          name: "init()",
          category: "model",
          type: "static",
          description: "Kh·ªüi t·∫°o model. T·∫°o collection v√† indexes n·∫øu c·∫ßn thi·∫øt.",
          usage: "Model.init()",
          example: "await User.init();\n// Model ƒë√£ s·∫µn s√†ng s·ª≠ d·ª•ng"
        },
        {
          name: "insertMany()",
          category: "model",
          type: "static",
          description: "Insert nhi·ªÅu documents c√πng l√∫c. Hi·ªáu qu·∫£ h∆°n create t·ª´ng c√°i.",
          usage: "Model.insertMany(docs, options)",
          example: "const users = await User.insertMany([\n  { name: 'John', age: 30 },\n  { name: 'Jane', age: 25 }\n], { ordered: false });"
        },
        {
          name: "inspect()",
          category: "model",
          type: "static",
          description: "Tr·∫£ v·ªÅ string representation c·ªßa Model cho debugging.",
          usage: "Model.inspect()",
          example: "console.log(User.inspect());\n// 'Model { User }'"
        },
        {
          name: "listIndexes()",
          category: "model",
          type: "static",
          description: "L·∫•y danh s√°ch t·∫•t c·∫£ indexes hi·ªán c√≥ trong collection.",
          usage: "Model.listIndexes()",
          example: "const indexes = await User.listIndexes();\nconsole.log('Current indexes:', indexes);"
        },
        {
          name: "mapReduce()",
          category: "model",
          type: "static",
          description: "Th·ª±c hi·ªán MapReduce operation tr√™n collection. Legacy feature.",
          usage: "Model.mapReduce(options)",
          example: "// Legacy - khuy√™n d√πng aggregate\nconst results = await User.mapReduce({\n  map: function() { emit(this.department, 1); },\n  reduce: function(key, values) { return values.length; }\n});"
        },
        {
          name: "populate()",
          category: "model",
          type: "static",
          description: "Populate documents ƒë√£ c√≥. Load references cho documents.",
          usage: "Model.populate(docs, options)",
          example: "const users = await User.find();\nawait User.populate(users, { path: 'posts', select: 'title' });"
        },
        {
          name: "$model()",
          category: "model",
          type: "method",
          description: "L·∫•y Model constructor t·ª´ document instance.",
          usage: "doc.$model(name)",
          example: "const UserModel = user.$model('User');\n// T∆∞∆°ng ƒë∆∞∆°ng User model"
        },
        {
          name: "$remove()",
          category: "model",
          type: "method",
          description: "X√≥a document instance kh·ªèi database. Deprecated - d√πng deleteOne().",
          usage: "doc.$remove(options)",
          example: "// Deprecated - s·ª≠ d·ª•ng deleteOne\n// await user.$remove();"
        },
        {
          name: "$where",
          category: "model",
          type: "property",
          description: "Property ƒë·ªÉ l∆∞u $where conditions tr√™n document instance.",
          usage: "doc.$where",
          example: "// Internal property\nconsole.log(user.$where);"
        },
        {
          name: "base",
          category: "model",
          type: "property",
          description: "Mongoose instance m√† model n√†y thu·ªôc v·ªÅ.",
          usage: "doc.base",
          example: "console.log(user.base === mongoose); // true\nconst version = user.base.version;"
        },
        {
          name: "baseModelName",
          category: "model",
          type: "property",
          description: "T√™n c·ªßa base model n·∫øu ƒë√¢y l√† discriminator.",
          usage: "doc.baseModelName",
          example: "console.log(employee.baseModelName); // 'User'\n// N·∫øu Employee l√† discriminator c·ªßa User"
        },
        {
          name: "collection",
          category: "model",
          type: "property",
          description: "MongoDB collection instance cho model n√†y.",
          usage: "Model.collection ho·∫∑c doc.collection",
          example: "const collection = User.collection;\nconst count = await collection.countDocuments();\nconst userCollection = user.collection;"
        },
        {
          name: "db",
          category: "model",
          type: "property",
          description: "Database instance t·ª´ document perspective.",
          usage: "doc.db",
          example: "console.log(user.db.name);\nconst admin = user.db.admin();"
        },
        {
          name: "deleteOne()",
          category: "model",
          type: "method",
          description: "X√≥a document instance kh·ªèi database. Thay th·∫ø cho remove().",
          usage: "doc.deleteOne(options)",
          example: "await user.deleteOne();\n// User document ƒë√£ b·ªã x√≥a kh·ªèi database"
        },
        {
          name: "discriminators",
          category: "model",
          type: "property",
          description: "Object ch·ª©a t·∫•t c·∫£ discriminator models c·ªßa model n√†y.",
          usage: "Model.discriminators ho·∫∑c doc.discriminators",
          example: "console.log(Object.keys(User.discriminators));\n// ['Employee', 'Customer']"
        },
        {
          name: "increment()",
          category: "model",
          type: "method",
          description: "TƒÉng __v version key c·ªßa document. D√πng cho optimistic concurrency.",
          usage: "doc.increment()",
          example: "user.increment();\nawait user.save();\n// __v s·∫Ω tƒÉng l√™n 1"
        },
        {
          name: "model()",
          category: "model",
          type: "method",
          description: "L·∫•y Model constructor t·ª´ document, c√≥ th·ªÉ ch·ªâ ƒë·ªãnh t√™n model kh√°c.",
          usage: "doc.model(name)",
          example: "const Post = user.model('Post');\n// L·∫•y Post model t·ª´ user document"
        },
        {
          name: "modelName",
          category: "model",
          type: "property",
          description: "T√™n c·ªßa model.",
          usage: "Model.modelName ho·∫∑c doc.modelName",
          example: "console.log(User.modelName); // 'User'\nconsole.log(user.modelName); // 'User'"
        },
        {
          name: "remove()",
          category: "model",
          type: "method",
          description: "X√≥a document instance. Deprecated - s·ª≠ d·ª•ng deleteOne().",
          usage: "doc.remove(options)",
          example: "// Deprecated - s·ª≠ d·ª•ng deleteOne\n// await user.remove();"
        },
        {
          name: "save()",
          category: "model",
          type: "method",
          description: "L∆∞u document instance v√†o database. Create n·∫øu new, update n·∫øu modified.",
          usage: "doc.save(options)",
          example: "user.name = 'John Doe';\nawait user.save();\n// Document ƒë√£ ƒë∆∞·ª£c update"
        },
        {
          name: "remove()",
          category: "model",
          type: "static",
          description: "X√≥a documents match ƒëi·ªÅu ki·ªán. Deprecated - s·ª≠ d·ª•ng deleteMany().",
          usage: "Model.remove(conditions, callback)",
          example: "// Deprecated - s·ª≠ d·ª•ng deleteMany\n// await User.remove({ active: false });"
        },
        {
          name: "replaceOne()",
          category: "model",
          type: "static",
          description: "Thay th·∫ø m·ªôt document trong database v·ªõi document m·ªõi.",
          usage: "Model.replaceOne(filter, replacement, options)",
          example: "const result = await User.replaceOne(\n  { name: 'John' },\n  { name: 'John Doe', age: 30, email: 'john@example.com' }\n);\nconsole.log('Modified:', result.modifiedCount);"
        },
        {
          name: "schema",
          category: "model",
          type: "static",
          description: "Schema instance m√† model n√†y d·ª±a tr√™n.",
          usage: "Model.schema",
          example: "console.log(Object.keys(User.schema.paths));\nconst nameType = User.schema.path('name');"
        },
        {
          name: "startSession()",
          category: "model",
          type: "static",
          description: "B·∫Øt ƒë·∫ßu client session cho model. Wrapper cho connection.startSession().",
          usage: "Model.startSession(options)",
          example: "const session = await User.startSession();\nawait session.startTransaction();\ntry {\n  await User.create([{name: 'John'}], {session});\n  await session.commitTransaction();\n} catch (error) {\n  await session.abortTransaction();\n}"
        },
        {
          name: "syncIndexes()",
          category: "model",
          type: "static",
          description: "ƒê·ªìng b·ªô indexes - t·∫°o m·ªõi v√† x√≥a indexes kh√¥ng c·∫ßn thi·∫øt.",
          usage: "Model.syncIndexes(options)",
          example: "await User.syncIndexes();\n// Indexes ƒë√£ ƒë∆∞·ª£c ƒë·ªìng b·ªô v·ªõi schema definition"
        },
        {
          name: "translateAliases()",
          category: "model",
          type: "static",
          description: "Chuy·ªÉn ƒë·ªïi aliases trong object th√†nh t√™n field th·ª±c t·∫ø.",
          usage: "Model.translateAliases(raw)",
          example: "const translated = User.translateAliases({\n  n: 'John', // n l√† alias c·ªßa name\n  a: 30      // a l√† alias c·ªßa age\n});\n// { name: 'John', age: 30 }"
        },
        {
          name: "update()",
          category: "model",
          type: "static",
          description: "Update documents match ƒëi·ªÅu ki·ªán. Deprecated - s·ª≠ d·ª•ng updateMany().",
          usage: "Model.update(conditions, update, options)",
          example: "// Deprecated - s·ª≠ d·ª•ng updateMany\n// await User.update({}, { $set: { active: true } });"
        },
        {
          name: "updateMany()",
          category: "model",
          type: "static",
          description: "Update nhi·ªÅu documents match ƒëi·ªÅu ki·ªán.",
          usage: "Model.updateMany(filter, update, options)",
          example: "const result = await User.updateMany(\n  { active: false },\n  { $set: { status: 'inactive' } }\n);\nconsole.log('Updated:', result.modifiedCount);"
        },
        {
          name: "updateOne()",
          category: "model",
          type: "static",
          description: "Update m·ªôt document ƒë·∫ßu ti√™n match ƒëi·ªÅu ki·ªán.",
          usage: "Model.updateOne(filter, update, options)",
          example: "const result = await User.updateOne(\n  { name: 'John' },\n  { $inc: { loginCount: 1 } }\n);\nconsole.log('Updated:', result.modifiedCount);"
        },
        {
          name: "validate()",
          category: "model",
          type: "static",
          description: "Validate object theo schema c·ªßa model m√† kh√¥ng t·∫°o document.",
          usage: "Model.validate(obj, pathsToValidate)",
          example: "try {\n  await User.validate({ name: 'John', age: 'invalid' });\n} catch (error) {\n  console.log('Validation error:', error);\n}"
        },
        {
          name: "watch()",
          category: "model",
          type: "static",
          description: "T·∫°o change stream ƒë·ªÉ theo d√µi thay ƒë·ªïi trong collection.",
          usage: "Model.watch(pipeline, options)",
          example: "const changeStream = User.watch([{ $match: { 'fullDocument.active': true } }]);\nchangeStream.on('change', (change) => {\n  console.log('User changed:', change);\n});"
        },
        {
          name: "where()",
          category: "model",
          type: "static",
          description: "T·∫°o Query object v·ªõi ƒëi·ªÅu ki·ªán ban ƒë·∫ßu. Fluent interface cho queries.",
          usage: "Model.where(path, val)",
          example: "const users = await User\n  .where('age').gte(18)\n  .where('active').equals(true)\n  .select('name email')\n  .limit(10);"
        }
      ],
      // Query API Data - Th√™m v√†o object apiData trong HTML
      query: [
        {
          name: "Query()",
          category: "query",
          type: "constructor",
          description: "Constructor ƒë·ªÉ t·∫°o Query instance. Base class cho t·∫•t c·∫£ MongoDB queries.",
          usage: "new Query(options, model, conditions, collection)",
          example: "const query = new mongoose.Query({}, User, { name: 'John' });\n// T·∫°o query instance"
        },
        {
          name: "$where()",
          category: "query",
          type: "method",
          description: "Th√™m $where condition s·ª≠ d·ª•ng JavaScript expression.",
          usage: "query.$where(js)",
          example: "const users = await User.find().$where('this.age > 18');\n// S·ª≠ d·ª•ng JavaScript trong query"
        },
        {
          name: "all()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh array ph·∫£i ch·ª©a t·∫•t c·∫£ c√°c gi√° tr·ªã. MongoDB $all operator.",
          usage: "query.all(path, vals)",
          example: "const users = await User.find().all('tags', ['javascript', 'nodejs']);\n// Tags ph·∫£i ch·ª©a c·∫£ hai values"
        },
        {
          name: "allowDiskUse()",
          category: "query",
          type: "method",
          description: "Cho ph√©p MongoDB s·ª≠ d·ª•ng disk space cho operations l·ªõn.",
          usage: "query.allowDiskUse(value)",
          example: "const result = await User.aggregate(pipeline).allowDiskUse(true);\n// Cho ph√©p s·ª≠ d·ª•ng disk cho aggregation"
        },
        {
          name: "and()",
          category: "query",
          type: "method",
          description: "Th√™m $and condition. T·∫•t c·∫£ conditions ph·∫£i ƒë√∫ng.",
          usage: "query.and(array)",
          example: "const users = await User.find().and([\n  { age: { $gte: 18 } },\n  { active: true }\n]);"
        },
        {
          name: "batchSize()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p s·ªë documents MongoDB tr·∫£ v·ªÅ trong m·ªói batch.",
          usage: "query.batchSize(val)",
          example: "const cursor = User.find().batchSize(100).cursor();\n// M·ªói batch 100 documents"
        },
        {
          name: "box()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh rectangular area cho geospatial query.",
          usage: "query.box(path, val)",
          example: "const locations = await Location.find().box('coordinates', \n  [[0, 0], [10, 10]]\n);"
        },
        {
          name: "cast()",
          category: "query",
          type: "method",
          description: "Cast query conditions theo schema types.",
          usage: "query.cast(model, obj)",
          example: "// Internal method ƒë·ªÉ cast query values\nquery.cast(User, { age: '25' }); // string -> number"
        },
        {
          name: "catch()",
          category: "query",
          type: "method",
          description: "Th√™m error handler cho query Promise.",
          usage: "query.catch(onReject)",
          example: "User.find({ invalid: 'query' })\n  .catch(err => console.error('Query failed:', err));"
        },
        {
          name: "center()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh center point cho geospatial $center query.",
          usage: "query.center(path, area)",
          example: "const locations = await Location.find()\n  .center('coordinates', [[0, 0], 5]);"
        },
        {
          name: "centerSphere()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh center point cho spherical geospatial query.",
          usage: "query.centerSphere(path, area)",
          example: "const locations = await Location.find()\n  .centerSphere('coordinates', [[0, 0], 0.1]);"
        },
        {
          name: "circle()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh circular area cho geospatial query.",
          usage: "query.circle(path, area)",
          example: "const locations = await Location.find()\n  .circle('coordinates', [[0, 0], 5]);"
        },
        {
          name: "clone()",
          category: "query",
          type: "method",
          description: "T·∫°o b·∫£n sao c·ªßa query. Deep clone t·∫•t c·∫£ conditions v√† options.",
          usage: "query.clone()",
          example: "const baseQuery = User.find({ active: true });\nconst adminQuery = baseQuery.clone().where('role', 'admin');"
        },
        {
          name: "collation()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p collation cho string comparison trong query.",
          usage: "query.collation(value)",
          example: "const users = await User.find({ name: 'john' })\n  .collation({ locale: 'en', strength: 1 }); // Case insensitive"
        },
        {
          name: "comment()",
          category: "query",
          type: "method",
          description: "Th√™m comment v√†o query ƒë·ªÉ debugging ho·∫∑c profiling.",
          usage: "query.comment(val)",
          example: "const users = await User.find()\n  .comment('Finding active users for dashboard');"
        },
        {
          name: "count()",
          category: "query",
          type: "method",
          description: "ƒê·∫øm documents match query. Deprecated - s·ª≠ d·ª•ng countDocuments().",
          usage: "query.count(filter)",
          example: "// Deprecated - s·ª≠ d·ª•ng countDocuments\n// const count = await User.find().count();"
        },
        {
          name: "countDocuments()",
          category: "query",
          type: "method",
          description: "ƒê·∫øm documents match query conditions.",
          usage: "query.countDocuments(filter)",
          example: "const activeCount = await User.find({ active: true }).countDocuments();\nconst totalCount = await User.countDocuments();"
        },
        {
          name: "cursor()",
          category: "query",
          type: "method",
          description: "Tr·∫£ v·ªÅ QueryCursor ƒë·ªÉ iterate qua k·∫øt qu·∫£ l·ªõn m·ªôt c√°ch hi·ªáu qu·∫£.",
          usage: "query.cursor(options)",
          example: "const cursor = User.find().cursor();\nfor (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n  console.log(doc.name);\n}"
        },
        {
          name: "deleteMany()",
          category: "query",
          type: "method",
          description: "X√≥a nhi·ªÅu documents match query conditions.",
          usage: "query.deleteMany(filter)",
          example: "const result = await User.find({ active: false }).deleteMany();\nconsole.log('Deleted:', result.deletedCount);"
        },
        {
          name: "deleteOne()",
          category: "query",
          type: "method",
          description: "X√≥a m·ªôt document ƒë·∫ßu ti√™n match query conditions.",
          usage: "query.deleteOne(filter)",
          example: "const result = await User.find({ name: 'John' }).deleteOne();\nconsole.log('Deleted:', result.deletedCount);"
        },
        {
          name: "distinct()",
          category: "query",
          type: "method",
          description: "L·∫•y c√°c gi√° tr·ªã unique c·ªßa field t·ª´ query results.",
          usage: "query.distinct(field, filter)",
          example: "const departments = await User.find({ active: true }).distinct('department');\nconsole.log('Active departments:', departments);"
        },
        {
          name: "elemMatch()",
          category: "query",
          type: "method",
          description: "Match documents v·ªõi array field ch·ª©a element th·ªèa m√£n ƒëi·ªÅu ki·ªán.",
          usage: "query.elemMatch(path, filter)",
          example: "const users = await User.find()\n  .elemMatch('skills', { name: 'JavaScript', level: { $gte: 5 } });"
        },
        {
          name: "equals()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh equality condition cho path hi·ªán t·∫°i.",
          usage: "query.equals(val)",
          example: "const users = await User.find().where('name').equals('John');\n// T∆∞∆°ng ƒë∆∞∆°ng User.find({ name: 'John' })"
        },
        {
          name: "error()",
          category: "query",
          type: "method",
          description: "L·∫•y ho·∫∑c thi·∫øt l·∫≠p error cho query.",
          usage: "query.error(err)",
          example: "const err = query.error();\nif (err) console.log('Query error:', err);"
        },
        {
          name: "estimatedDocumentCount()",
          category: "query",
          type: "method",
          description: "∆Ø·ªõc t√≠nh s·ªë documents trong collection. Nhanh nh∆∞ng kh√¥ng ch√≠nh x√°c.",
          usage: "query.estimatedDocumentCount(options)",
          example: "const estimate = await User.estimatedDocumentCount();\nconsole.log('Estimated users:', estimate);"
        },
        {
          name: "exec()",
          category: "query",
          type: "method",
          description: "Th·ª±c thi query v√† tr·∫£ v·ªÅ Promise v·ªõi k·∫øt qu·∫£.",
          usage: "query.exec(callback)",
          example: "const users = await User.find({ active: true }).exec();\n// Ho·∫∑c v·ªõi callback\nUser.find().exec((err, users) => { /* handle result */ });"
        },
        {
          name: "exists()",
          category: "query",
          type: "method",
          description: "Ki·ªÉm tra field c√≥ t·ªìn t·∫°i ho·∫∑c kh√¥ng t·ªìn t·∫°i.",
          usage: "query.exists(path, val)",
          example: "const usersWithEmail = await User.find().exists('email', true);\nconst usersWithoutBio = await User.find().exists('bio', false);"
        },
        {
          name: "explain()",
          category: "query",
          type: "method",
          description: "Tr·∫£ v·ªÅ query execution plan thay v√¨ k·∫øt qu·∫£ query.",
          usage: "query.explain(verbose)",
          example: "const plan = await User.find({ name: 'John' }).explain('executionStats');\nconsole.log('Execution time:', plan.executionStats.executionTimeMillis);"
        },
        {
          name: "find()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p query conditions v√† tr·∫£ v·ªÅ Query object.",
          usage: "query.find(filter)",
          example: "const query = User.find().find({ active: true });\nconst users = await query.exec();"
        },
        {
          name: "findOne()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p query ƒë·ªÉ t√¨m m·ªôt document ƒë·∫ßu ti√™n.",
          usage: "query.findOne(filter)",
          example: "const user = await User.find().findOne({ email: 'john@example.com' });"
        },
        {
          name: "findOneAndDelete()",
          category: "query",
          type: "method",
          description: "T√¨m v√† x√≥a m·ªôt document, tr·∫£ v·ªÅ document ƒë√£ x√≥a.",
          usage: "query.findOneAndDelete(filter, options)",
          example: "const deletedUser = await User.find({ name: 'John' }).findOneAndDelete();"
        },
        {
          name: "findOneAndRemove()",
          category: "query",
          type: "method",
          description: "T√¨m v√† x√≥a m·ªôt document. Deprecated - s·ª≠ d·ª•ng findOneAndDelete().",
          usage: "query.findOneAndRemove(conditions, options)",
          example: "// Deprecated - s·ª≠ d·ª•ng findOneAndDelete\n// const user = await User.find().findOneAndRemove();"
        },
        {
          name: "findOneAndReplace()",
          category: "query",
          type: "method",
          description: "T√¨m v√† thay th·∫ø to√†n b·ªô document.",
          usage: "query.findOneAndReplace(filter, replacement, options)",
          example: "const newUser = await User.find({ name: 'John' })\n  .findOneAndReplace({ name: 'John Doe', age: 30 }, { new: true });"
        },
        {
          name: "findOneAndUpdate()",
          category: "query",
          type: "method",
          description: "T√¨m v√† update m·ªôt document, tr·∫£ v·ªÅ document c≈© ho·∫∑c m·ªõi.",
          usage: "query.findOneAndUpdate(filter, update, options)",
          example: "const user = await User.find({ name: 'John' })\n  .findOneAndUpdate({ $inc: { age: 1 } }, { new: true });"
        },
        {
          name: "geometry()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh geometry object cho geospatial queries.",
          usage: "query.geometry(object)",
          example: "const locations = await Location.find()\n  .geometry({ type: 'Point', coordinates: [0, 0] });"
        },
        {
          name: "get()",
          category: "query",
          type: "method",
          description: "L·∫•y gi√° tr·ªã option ho·∫∑c condition t·ª´ query.",
          usage: "query.get(path)",
          example: "const limit = query.get('limit');\nconst nameCondition = query.get('name');"
        },
        {
          name: "getFilter()",
          category: "query",
          type: "method",
          description: "L·∫•y filter conditions c·ªßa query.",
          usage: "query.getFilter()",
          example: "const conditions = query.getFilter();\nconsole.log('Query conditions:', conditions);"
        },
        {
          name: "getOptions()",
          category: "query",
          type: "method",
          description: "L·∫•y t·∫•t c·∫£ options c·ªßa query.",
          usage: "query.getOptions()",
          example: "const options = query.getOptions();\nconsole.log('Query options:', options);"
        },
        {
          name: "getPopulatedPaths()",
          category: "query",
          type: "method",
          description: "L·∫•y array c√°c paths s·∫Ω ƒë∆∞·ª£c populate.",
          usage: "query.getPopulatedPaths()",
          example: "const populated = query.getPopulatedPaths();\nconsole.log('Will populate:', populated);"
        },
        {
          name: "getQuery()",
          category: "query",
          type: "method",
          description: "L·∫•y query conditions object. Alias cho getFilter().",
          usage: "query.getQuery()",
          example: "const conditions = query.getQuery();\nconsole.log('Query conditions:', conditions);"
        },
        {
          name: "getUpdate()",
          category: "query",
          type: "method",
          description: "L·∫•y update operations t·ª´ update query.",
          usage: "query.getUpdate()",
          example: "const updateOps = query.getUpdate();\nconsole.log('Update operations:', updateOps);"
        },
        {
          name: "gt()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh greater than condition ($gt).",
          usage: "query.gt(path, val)",
          example: "const users = await User.find().where('age').gt(18);\n// age > 18"
        },
        {
          name: "gte()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh greater than or equal condition ($gte).",
          usage: "query.gte(path, val)",
          example: "const users = await User.find().where('age').gte(18);\n// age >= 18"
        },
        {
          name: "hint()",
          category: "query",
          type: "method",
          description: "G·ª£i √Ω MongoDB s·ª≠ d·ª•ng index c·ª• th·ªÉ cho query.",
          usage: "query.hint(val)",
          example: "const users = await User.find({ email: 'john@example.com' })\n  .hint({ email: 1 }); // S·ª≠ d·ª•ng email index"
        },
        {
          name: "in()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh values ph·∫£i c√≥ trong array ($in operator).",
          usage: "query.in(path, val)",
          example: "const users = await User.find().where('status').in(['active', 'pending']);"
        },
        {
          name: "intersects()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh geometry intersection cho geospatial query.",
          usage: "query.intersects(arg)",
          example: "const locations = await Location.find()\n  .intersects({ type: 'Polygon', coordinates: [...] });"
        },
        {
          name: "j()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p journaled write concern. ƒê·∫£m b·∫£o write ƒë∆∞·ª£c ghi v√†o journal.",
          usage: "query.j(val)",
          example: "await User.updateOne({ name: 'John' }, { age: 30 }).j(true);\n// Write ph·∫£i ƒë∆∞·ª£c journaled"
        },
        {
          name: "lean()",
          category: "query",
          type: "method",
          description: "Tr·∫£ v·ªÅ plain JavaScript objects thay v√¨ Mongoose documents.",
          usage: "query.lean(val)",
          example: "const users = await User.find().lean();\n// users l√† plain objects, kh√¥ng c√≥ Mongoose methods"
        },
        {
          name: "limit()",
          category: "query",
          type: "method",
          description: "Gi·ªõi h·∫°n s·ªë documents tr·∫£ v·ªÅ.",
          usage: "query.limit(val)",
          example: "const users = await User.find().limit(10);\n// Ch·ªâ l·∫•y 10 users ƒë·∫ßu ti√™n"
        },
        {
          name: "lt()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh less than condition ($lt).",
          usage: "query.lt(path, val)",
          example: "const youngUsers = await User.find().where('age').lt(25);\n// age < 25"
        },
        {
          name: "lte()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh less than or equal condition ($lte).",
          usage: "query.lte(path, val)",
          example: "const users = await User.find().where('age').lte(65);\n// age <= 65"
        },
        {
          name: "maxDistance()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh maximum distance cho geospatial queries.",
          usage: "query.maxDistance(path, val)",
          example: "const nearby = await Location.find()\n  .near('coordinates', [0, 0])\n  .maxDistance(1000); // Within 1000 meters"
        },
        {
          name: "maxScan()",
          category: "query",
          type: "method",
          description: "Gi·ªõi h·∫°n s·ªë documents MongoDB scan. Deprecated.",
          usage: "query.maxScan(val)",
          example: "// Deprecated trong MongoDB 4.0+\n// const users = await User.find().maxScan(1000);"
        },
        {
          name: "maxTimeMS()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p timeout cho query execution.",
          usage: "query.maxTimeMS(ms)",
          example: "const users = await User.find().maxTimeMS(5000);\n// Query timeout sau 5 gi√¢y"
        },
        {
          name: "maxscan()",
          category: "query",
          type: "method",
          description: "Alias cho maxScan(). Deprecated.",
          usage: "query.maxscan(val)",
          example: "// Deprecated - alias c·ªßa maxScan\n// const users = await User.find().maxscan(1000);"
        },
        {
          name: "merge()",
          category: "query",
          type: "method",
          description: "Merge query object v√†o query hi·ªán t·∫°i.",
          usage: "query.merge(source)",
          example: "const baseQuery = { active: true };\nconst users = await User.find().merge(baseQuery).merge({ age: { $gte: 18 } });"
        },
        {
          name: "mod()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh modulus condition ($mod operator).",
          usage: "query.mod(path, val)",
          example: "const evenIds = await User.find().mod('_id', [2, 0]);\n// _id % 2 == 0"
        },
        {
          name: "model",
          category: "query",
          type: "property",
          description: "Model instance m√† query n√†y thu·ªôc v·ªÅ.",
          usage: "query.model",
          example: "console.log('Query model:', query.model.modelName);\nconst schema = query.model.schema;"
        },
        {
          name: "mongooseOptions()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p Mongoose-specific options cho query.",
          usage: "query.mongooseOptions(options)",
          example: "const users = await User.find()\n  .mongooseOptions({ lean: true, autopopulate: false });"
        },
        {
          name: "ne()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh not equal condition ($ne).",
          usage: "query.ne(path, val)",
          example: "const activeUsers = await User.find().where('status').ne('deleted');\n// status != 'deleted'"
        },
        {
          name: "near()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh geospatial $near condition.",
          usage: "query.near(path, val)",
          example: "const nearby = await Location.find()\n  .near('coordinates', { type: 'Point', coordinates: [0, 0] });"
        },
        {
          name: "nearSphere()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh spherical geospatial $nearSphere condition.",
          usage: "query.nearSphere(path, val)",
          example: "const nearby = await Location.find()\n  .nearSphere('coordinates', [0, 0], { maxDistance: 1000 });"
        },
        {
          name: "nin()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh values kh√¥ng ƒë∆∞·ª£c c√≥ trong array ($nin operator).",
          usage: "query.nin(path, val)",
          example: "const users = await User.find().where('status').nin(['deleted', 'banned']);"
        },
        {
          name: "nor()",
          category: "query",
          type: "method",
          description: "Th√™m $nor condition. Kh√¥ng c√≥ condition n√†o ƒë∆∞·ª£c ƒë√∫ng.",
          usage: "query.nor(array)",
          example: "const users = await User.find().nor([\n  { age: { $lt: 18 } },\n  { status: 'inactive' }\n]);"
        },
        {
          name: "or()",
          category: "query",
          type: "method",
          description: "Th√™m $or condition. √çt nh·∫•t m·ªôt condition ph·∫£i ƒë√∫ng.",
          usage: "query.or(array)",
          example: "const users = await User.find().or([\n  { name: 'John' },\n  { email: 'john@example.com' }\n]);"
        },
        {
          name: "orFail()",
          category: "query",
          type: "method",
          description: "N√©m l·ªói n·∫øu query kh√¥ng t√¨m th·∫•y document n√†o.",
          usage: "query.orFail(err)",
          example: "try {\n  const user = await User.findOne({ name: 'John' }).orFail();\n} catch (error) {\n  console.log('User not found');\n}"
        },
        {
          name: "polygon()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh polygon area cho geospatial query.",
          usage: "query.polygon(path, coordinateArray)",
          example: "const locations = await Location.find()\n  .polygon('coordinates', [[0,0], [1,1], [1,0], [0,0]]);"
        },
        {
          name: "populate()",
          category: "query",
          type: "method",
          description: "Populate references v·ªõi documents t·ª´ collections kh√°c.",
          usage: "query.populate(path, select, model, match, options)",
          example: "const users = await User.find()\n  .populate('posts', 'title content')\n  .populate({ path: 'comments', match: { approved: true } });"
        },
        {
          name: "post()",
          category: "query",
          type: "method",
          description: "Th√™m post middleware cho query. Ch·∫°y sau khi query ho√†n th√†nh.",
          usage: "query.post(method, fn)",
          example: "User.find().post('find', function(docs) {\n  console.log('Found', docs.length, 'users');\n});"
        },
        {
          name: "pre()",
          category: "query",
          type: "method",
          description: "Th√™m pre middleware cho query. Ch·∫°y tr∆∞·ªõc khi query th·ª±c thi.",
          usage: "query.pre(method, fn)",
          example: "User.find().pre('find', function() {\n  console.log('About to execute find query');\n});"
        },
        {
          name: "projection()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p projection cho query. Ch·ªâ ƒë·ªãnh fields c·∫ßn tr·∫£ v·ªÅ.",
          usage: "query.projection(fields)",
          example: "const users = await User.find()\n  .projection({ name: 1, email: 1, _id: 0 });"
        },
        {
          name: "read()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p read preference cho query.",
          usage: "query.read(pref, tags)",
          example: "const users = await User.find().read('secondary');\n// ƒê·ªçc t·ª´ secondary replica"
        },
        {
          name: "readConcern()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p read concern cho query.",
          usage: "query.readConcern(level)",
          example: "const users = await User.find().readConcern('majority');\n// ƒê·∫£m b·∫£o ƒë·ªçc data ƒë√£ ƒë∆∞·ª£c majority acknowledge"
        },
        {
          name: "regex()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh regular expression condition.",
          usage: "query.regex(path, val)",
          example: "const users = await User.find().where('name').regex(/^John/i);\n// T√™n b·∫Øt ƒë·∫ßu v·ªõi 'John' (case insensitive)"
        },
        {
          name: "remove()",
          category: "query",
          type: "method",
          description: "X√≥a documents match query. Deprecated - s·ª≠ d·ª•ng deleteMany().",
          usage: "query.remove(filter)",
          example: "// Deprecated - s·ª≠ d·ª•ng deleteMany\n// await User.find({ active: false }).remove();"
        },
        {
          name: "replaceOne()",
          category: "query",
          type: "method",
          description: "Thay th·∫ø m·ªôt document v·ªõi document m·ªõi ho√†n to√†n.",
          usage: "query.replaceOne(filter, replacement, options)",
          example: "const result = await User.find({ name: 'John' })\n  .replaceOne({ name: 'John Doe', age: 30, email: 'john@example.com' });"
        },
        {
          name: "select()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh fields c·∫ßn include ho·∫∑c exclude trong k·∫øt qu·∫£.",
          usage: "query.select(arg)",
          example: "const users = await User.find().select('name email');\nconst usersNoPassword = await User.find().select('-password');"
        },
        {
          name: "selected()",
          category: "query",
          type: "method",
          description: "Ki·ªÉm tra xem field c√≥ ƒë∆∞·ª£c select kh√¥ng.",
          usage: "query.selected()",
          example: "const isSelected = query.selected();\nconsole.log('Selected fields:', isSelected);"
        },
        {
          name: "selectedExclusively()",
          category: "query",
          type: "method",
          description: "Ki·ªÉm tra xem projection c√≥ ph·∫£i exclusive (ch·ªâ select m·ªôt s·ªë fields).",
          usage: "query.selectedExclusively()",
          example: "const isExclusive = query.selectedExclusively();\nif (isExclusive) console.log('Using exclusive projection');"
        },
        {
          name: "selectedInclusively()",
          category: "query",
          type: "method",
          description: "Ki·ªÉm tra xem projection c√≥ ph·∫£i inclusive (exclude m·ªôt s·ªë fields).",
          usage: "query.selectedInclusively()",
          example: "const isInclusive = query.selectedInclusively();\nif (isInclusive) console.log('Using inclusive projection');"
        },
        {
          name: "session()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p session cho query (ƒë·ªÉ s·ª≠ d·ª•ng transactions).",
          usage: "query.session(session)",
          example: "const session = await mongoose.startSession();\nconst users = await User.find().session(session);"
        },
        {
          name: "set()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p query conditions ho·∫∑c options.",
          usage: "query.set(path, val)",
          example: "const query = User.find();\nquery.set('name', 'John');\nquery.set('limit', 10);"
        },
        {
          name: "setOptions()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p query options t·ª´ object.",
          usage: "query.setOptions(options)",
          example: "query.setOptions({\n  limit: 10,\n  sort: { name: 1 },\n  lean: true\n});"
        },
        {
          name: "setQuery()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p query conditions t·ª´ object.",
          usage: "query.setQuery(conditions)",
          example: "query.setQuery({ name: 'John', age: { $gte: 18 } });"
        },
        {
          name: "setUpdate()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p update operations cho update queries.",
          usage: "query.setUpdate(update)",
          example: "query.setUpdate({ $set: { age: 30 }, $inc: { loginCount: 1 } });"
        },
        {
          name: "size()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh array ph·∫£i c√≥ size c·ª• th·ªÉ ($size operator).",
          usage: "query.size(path, val)",
          example: "const users = await User.find().where('tags').size(3);\n// tags array ph·∫£i c√≥ ƒë√∫ng 3 elements"
        },
        {
          name: "skip()",
          category: "query",
          type: "method",
          description: "B·ªè qua s·ªë documents ƒë·∫ßu ti√™n trong k·∫øt qu·∫£.",
          usage: "query.skip(val)",
          example: "const users = await User.find().skip(10).limit(5);\n// B·ªè qua 10 documents ƒë·∫ßu, l·∫•y 5 documents ti·∫øp theo"
        },
        {
          name: "slice()",
          category: "query",
          type: "method",
          description: "Gi·ªõi h·∫°n s·ªë elements tr·∫£ v·ªÅ trong array field.",
          usage: "query.slice(path, val)",
          example: "const users = await User.find().slice('posts', 5);\n// Ch·ªâ tr·∫£ v·ªÅ 5 posts ƒë·∫ßu ti√™n trong m·ªói user"
        },
        {
          name: "snapshot()",
          category: "query",
          type: "method",
          description: "S·ª≠ d·ª•ng snapshot mode ƒë·ªÉ tr√°nh duplicate results. Deprecated.",
          usage: "query.snapshot()",
          example: "// Deprecated trong MongoDB 3.6+\n// const users = await User.find().snapshot();"
        },
        {
          name: "sort()",
          category: "query",
          type: "method",
          description: "S·∫Øp x·∫øp k·∫øt qu·∫£ theo fields c·ª• th·ªÉ.",
          usage: "query.sort(arg)",
          example: "const users = await User.find().sort({ name: 1, age: -1 });\n// Sort theo name (tƒÉng d·∫ßn), r·ªìi age (gi·∫£m d·∫ßn)"
        },
        {
          name: "tailable()",
          category: "query",
          type: "method",
          description: "T·∫°o tailable cursor cho capped collections.",
          usage: "query.tailable(bool, opts)",
          example: "const cursor = Log.find().tailable().cursor();\n// Cursor s·∫Ω kh√¥ng ƒë√≥ng khi h·∫øt documents"
        },
        {
          name: "then()",
          category: "query",
          type: "method",
          description: "Th√™m success handler cho query Promise.",
          usage: "query.then(onFulfilled, onRejected)",
          example: "User.find({ name: 'John' })\n  .then(users => console.log('Found users:', users))\n  .catch(err => console.error('Error:', err));"
        },
        {
          name: "toConstructor()",
          category: "query",
          type: "method",
          description: "Chuy·ªÉn query th√†nh constructor function c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng.",
          usage: "query.toConstructor()",
          example: "const FindActiveUsers = User.find({ active: true }).toConstructor();\nconst users1 = await new FindActiveUsers().exec();\nconst users2 = await new FindActiveUsers().limit(5).exec();"
        },
        {
          name: "transform()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p transform function ƒë·ªÉ modify k·∫øt qu·∫£ query.",
          usage: "query.transform(fn)",
          example: "const users = await User.find()\n  .transform(docs => docs.map(doc => ({ name: doc.name, id: doc._id })));"
        },
        {
          name: "update()",
          category: "query",
          type: "method",
          description: "Update documents match query. Deprecated - s·ª≠ d·ª•ng updateMany().",
          usage: "query.update(filter, update, options)",
          example: "// Deprecated - s·ª≠ d·ª•ng updateMany\n// await User.find({ active: false }).update({ status: 'inactive' });"
        },
        {
          name: "updateMany()",
          category: "query",
          type: "method",
          description: "Update nhi·ªÅu documents match query conditions.",
          usage: "query.updateMany(filter, update, options)",
          example: "const result = await User.find({ active: false })\n  .updateMany({ $set: { status: 'inactive' } });\nconsole.log('Updated:', result.modifiedCount);"
        },
        {
          name: "updateOne()",
          category: "query",
          type: "method",
          description: "Update m·ªôt document ƒë·∫ßu ti√™n match query conditions.",
          usage: "query.updateOne(filter, update, options)",
          example: "const result = await User.find({ name: 'John' })\n  .updateOne({ $inc: { loginCount: 1 } });\nconsole.log('Updated:', result.modifiedCount);"
        },
        {
          name: "w()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p write concern acknowledgment cho query.",
          usage: "query.w(val)",
          example: "await User.updateOne({ name: 'John' }, { age: 30 }).w('majority');\n// Write ph·∫£i ƒë∆∞·ª£c acknowledge b·ªüi majority"
        },
        {
          name: "where()",
          category: "query",
          type: "method",
          description: "T·∫°o fluent interface ƒë·ªÉ build query conditions.",
          usage: "query.where(path, val)",
          example: "const users = await User.find()\n  .where('age').gte(18)\n  .where('active').equals(true)\n  .where('name').regex(/^J/);"
        },
        {
          name: "within()",
          category: "query",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh geospatial $within condition.",
          usage: "query.within(val)",
          example: "const locations = await Location.find()\n  .within({ $geometry: { type: 'Polygon', coordinates: [...] } });"
        },
        {
          name: "writeConcern()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p write concern options cho query.",
          usage: "query.writeConcern(concern)",
          example: "await User.updateOne({ name: 'John' }, { age: 30 })\n  .writeConcern({ w: 'majority', j: true });"
        },
        {
          name: "wtimeout()",
          category: "query",
          type: "method",
          description: "Thi·∫øt l·∫≠p timeout cho write concern acknowledgment.",
          usage: "query.wtimeout(ms)",
          example: "await User.updateOne({ name: 'John' }, { age: 30 })\n  .w('majority').wtimeout(5000); // Timeout 5 seconds"
        },
        {
          name: "[Symbol.asyncIterator]()",
          category: "query",
          type: "method",
          description: "Cho ph√©p s·ª≠ d·ª•ng for-await-of loop v·ªõi query cursor.",
          usage: "for await (const doc of query) { ... }",
          example: "for await (const user of User.find().cursor()) {\n  console.log('Processing user:', user.name);\n  // X·ª≠ l√Ω t·ª´ng user m·ªôt c√°ch memory-efficient\n}"
        },
        {
          name: "use$geoWithin",
          category: "query",
          type: "static",
          description: "Static flag ƒë·ªÉ s·ª≠ d·ª•ng $geoWithin thay v√¨ $within. MongoDB 2.4+.",
          usage: "Query.use$geoWithin",
          example: "mongoose.Query.use$geoWithin = true;\n// S·ª≠ d·ª•ng $geoWithin cho t·∫•t c·∫£ geospatial queries"
        }
      ],// Aggregate API Data - Th√™m v√†o object apiData trong HTML
      aggregate: [
        {
          name: "Aggregate()",
          category: "aggregate",
          type: "constructor",
          description: "Constructor ƒë·ªÉ t·∫°o Aggregation pipeline. X·ª≠ l√Ω d·ªØ li·ªáu ph·ª©c t·∫°p v·ªõi nhi·ªÅu stages.",
          usage: "new Aggregate(pipeline)",
          example: "const agg = new mongoose.Aggregate([\n  { $match: { active: true } },\n  { $group: { _id: '$department', count: { $sum: 1 } } }\n]);"
        },
        {
          name: "addFields()",
          category: "aggregate",
          type: "method",
          description: "Th√™m fields m·ªõi v√†o documents. T∆∞∆°ng ƒë∆∞∆°ng $addFields stage.",
          usage: "aggregate.addFields(arg)",
          example: "const result = await User.aggregate()\n  .addFields({\n    fullName: { $concat: ['$firstName', ' ', '$lastName'] },\n    isAdult: { $gte: ['$age', 18] }\n  });"
        },
        {
          name: "allowDiskUse()",
          category: "aggregate",
          type: "method",
          description: "Cho ph√©p MongoDB s·ª≠ d·ª•ng disk space cho aggregation operations l·ªõn.",
          usage: "aggregate.allowDiskUse(value)",
          example: "const result = await User.aggregate([\n  { $group: { _id: '$department', users: { $push: '$$ROOT' } } }\n]).allowDiskUse(true);"
        },
        {
          name: "append()",
          category: "aggregate",
          type: "method",
          description: "Th√™m stage m·ªõi v√†o cu·ªëi aggregation pipeline.",
          usage: "aggregate.append(...args)",
          example: "const agg = User.aggregate().match({ active: true });\nagg.append({ $sort: { name: 1 } });\nagg.append({ $limit: 10 });"
        },
        {
          name: "catch()",
          category: "aggregate",
          type: "method",
          description: "Th√™m error handler cho aggregation Promise.",
          usage: "aggregate.catch(onRejected)",
          example: "User.aggregate([{ $match: { invalid: true } }])\n  .catch(err => {\n    console.error('Aggregation failed:', err);\n  });"
        },
        {
          name: "collation()",
          category: "aggregate",
          type: "method",
          description: "Thi·∫øt l·∫≠p collation cho string comparison trong aggregation.",
          usage: "aggregate.collation(options)",
          example: "const result = await User.aggregate([\n  { $match: { name: 'john' } }\n]).collation({ locale: 'en', strength: 1 }); // Case insensitive"
        },
        {
          name: "count()",
          category: "aggregate",
          type: "method",
          description: "ƒê·∫øm s·ªë documents pass qua stage tr∆∞·ªõc ƒë√≥. T∆∞∆°ng ƒë∆∞∆°ng $count stage.",
          usage: "aggregate.count(field)",
          example: "const result = await User.aggregate()\n  .match({ active: true })\n  .count('activeUsers');\n// { activeUsers: 150 }"
        },
        {
          name: "cursor()",
          category: "aggregate",
          type: "method",
          description: "Tr·∫£ v·ªÅ AggregationCursor ƒë·ªÉ iterate qua k·∫øt qu·∫£ l·ªõn m·ªôt c√°ch hi·ªáu qu·∫£.",
          usage: "aggregate.cursor(options)",
          example: "const cursor = User.aggregate([\n  { $match: { active: true } }\n]).cursor({ batchSize: 100 });\n\nfor (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n  console.log(doc);\n}"
        },
        {
          name: "densify()",
          category: "aggregate",
          type: "method",
          description: "T·∫°o documents cho missing values trong time series. MongoDB 5.1+.",
          usage: "aggregate.densify(arg)",
          example: "const result = await Sensor.aggregate()\n  .densify({\n    field: 'timestamp',\n    partitionByFields: ['sensorId'],\n    range: {\n      step: 1,\n      unit: 'hour',\n      bounds: 'full'\n    }\n  });"
        },
        {
          name: "exec()",
          category: "aggregate",
          type: "method",
          description: "Th·ª±c thi aggregation pipeline v√† tr·∫£ v·ªÅ Promise v·ªõi k·∫øt qu·∫£.",
          usage: "aggregate.exec(callback)",
          example: "const result = await User.aggregate([\n  { $match: { active: true } },\n  { $group: { _id: '$department', count: { $sum: 1 } } }\n]).exec();\n\nconsole.log('Departments:', result);"
        },
        {
          name: "explain()",
          category: "aggregate",
          type: "method",
          description: "Tr·∫£ v·ªÅ execution plan c·ªßa aggregation thay v√¨ k·∫øt qu·∫£.",
          usage: "aggregate.explain(verbosity)",
          example: "const plan = await User.aggregate([\n  { $match: { active: true } },\n  { $sort: { name: 1 } }\n]).explain('executionStats');\n\nconsole.log('Execution time:', plan.stages[0].executionStats.executionTimeMillisEstimate);"
        },
        {
          name: "facet()",
          category: "aggregate",
          type: "method",
          description: "T·∫°o multiple aggregation pipelines tr√™n c√πng input. T∆∞∆°ng ƒë∆∞∆°ng $facet stage.",
          usage: "aggregate.facet(facet)",
          example: "const result = await User.aggregate()\n  .facet({\n    byDepartment: [\n      { $group: { _id: '$department', count: { $sum: 1 } } }\n    ],\n    byAge: [\n      { $group: { _id: { $floor: { $divide: ['$age', 10] } }, count: { $sum: 1 } } }\n    ]\n  });"
        },
        {
          name: "fill()",
          category: "aggregate",
          type: "method",
          description: "ƒêi·ªÅn missing values trong time series data. MongoDB 5.3+.",
          usage: "aggregate.fill(arg)",
          example: "const result = await Sensor.aggregate()\n  .fill({\n    partitionBy: { sensorId: '$sensorId' },\n    partitionByFields: ['sensorId'],\n    sortBy: { timestamp: 1 },\n    output: {\n      temperature: { method: 'linear' },\n      humidity: { value: 50 }\n    }\n  });"
        },
        {
          name: "graphLookup()",
          category: "aggregate",
          type: "method",
          description: "Th·ª±c hi·ªán recursive search trong collection. T∆∞∆°ng ƒë∆∞∆°ng $graphLookup stage.",
          usage: "aggregate.graphLookup(options)",
          example: "const result = await Employee.aggregate()\n  .graphLookup({\n    from: 'employees',\n    startWith: '$reportsTo',\n    connectFromField: 'reportsTo',\n    connectToField: '_id',\n    as: 'reportingHierarchy',\n    maxDepth: 4\n  });"
        },
        {
          name: "group()",
          category: "aggregate",
          type: "method",
          description: "Nh√≥m documents theo criteria v√† t√≠nh to√°n. T∆∞∆°ng ƒë∆∞∆°ng $group stage.",
          usage: "aggregate.group(arg)",
          example: "const result = await Order.aggregate()\n  .group({\n    _id: '$customerId',\n    totalAmount: { $sum: '$amount' },\n    orderCount: { $sum: 1 },\n    avgAmount: { $avg: '$amount' },\n    orders: { $push: { orderId: '$_id', amount: '$amount' } }\n  });"
        },
        {
          name: "hint()",
          category: "aggregate",
          type: "method",
          description: "G·ª£i √Ω MongoDB s·ª≠ d·ª•ng index c·ª• th·ªÉ cho aggregation.",
          usage: "aggregate.hint(val)",
          example: "const result = await User.aggregate([\n  { $match: { email: { $regex: /@gmail\\.com$/ } } },\n  { $sort: { createdAt: -1 } }\n]).hint({ email: 1 });"
        },
        {
          name: "limit()",
          category: "aggregate",
          type: "method",
          description: "Gi·ªõi h·∫°n s·ªë documents pass qua stage. T∆∞∆°ng ƒë∆∞∆°ng $limit stage.",
          usage: "aggregate.limit(num)",
          example: "const result = await User.aggregate()\n  .match({ active: true })\n  .sort({ createdAt: -1 })\n  .limit(10); // L·∫•y 10 users m·ªõi nh·∫•t"
        },
        {
          name: "lookup()",
          category: "aggregate",
          type: "method",
          description: "Join v·ªõi collection kh√°c. T∆∞∆°ng ƒë∆∞∆°ng $lookup stage.",
          usage: "aggregate.lookup(options)",
          example: "const result = await User.aggregate()\n  .lookup({\n    from: 'posts',\n    localField: '_id',\n    foreignField: 'authorId',\n    as: 'posts'\n  })\n  .lookup({\n    from: 'profiles',\n    let: { userId: '$_id' },\n    pipeline: [\n      { $match: { $expr: { $eq: ['$userId', '$$userId'] } } },\n      { $project: { bio: 1, avatar: 1 } }\n    ],\n    as: 'profile'\n  });"
        },
        {
          name: "match()",
          category: "aggregate",
          type: "method",
          description: "Filter documents theo criteria. T∆∞∆°ng ƒë∆∞∆°ng $match stage.",
          usage: "aggregate.match(arg)",
          example: "const result = await User.aggregate()\n  .match({\n    active: true,\n    age: { $gte: 18, $lt: 65 },\n    department: { $in: ['engineering', 'design'] }\n  });"
        },
        {
          name: "model()",
          category: "aggregate",
          type: "method",
          description: "L·∫•y Model instance m√† aggregation n√†y thu·ªôc v·ªÅ.",
          usage: "aggregate.model(model)",
          example: "const agg = User.aggregate();\nconsole.log('Model name:', agg.model().modelName);\n// 'User'"
        },
        {
          name: "near()",
          category: "aggregate",
          type: "method",
          description: "Geospatial aggregation stage ƒë·ªÉ t√¨m documents g·∫ßn location. T∆∞∆°ng ƒë∆∞∆°ng $geoNear.",
          usage: "aggregate.near(arg)",
          example: "const result = await Location.aggregate()\n  .near({\n    near: { type: 'Point', coordinates: [0, 0] },\n    distanceField: 'distance',\n    maxDistance: 1000,\n    spherical: true\n  });"
        },
        {
          name: "option()",
          category: "aggregate",
          type: "method",
          description: "Thi·∫øt l·∫≠p option cho aggregation.",
          usage: "aggregate.option(options)",
          example: "const result = await User.aggregate(pipeline)\n  .option({\n    allowDiskUse: true,\n    maxTimeMS: 30000,\n    hint: { email: 1 }\n  });"
        },
        {
          name: "options",
          category: "aggregate",
          type: "property",
          description: "Object ch·ª©a t·∫•t c·∫£ options c·ªßa aggregation.",
          usage: "aggregate.options",
          example: "const agg = User.aggregate(pipeline).allowDiskUse(true);\nconsole.log('Options:', agg.options);\n// { allowDiskUse: true }"
        },
        {
          name: "pipeline()",
          category: "aggregate",
          type: "method",
          description: "L·∫•y ho·∫∑c thi·∫øt l·∫≠p aggregation pipeline.",
          usage: "aggregate.pipeline(pipeline)",
          example: "const agg = User.aggregate();\nagg.pipeline([\n  { $match: { active: true } },\n  { $group: { _id: '$department', count: { $sum: 1 } } }\n]);\n\nconsole.log('Pipeline:', agg.pipeline());"
        },
        {
          name: "project()",
          category: "aggregate",
          type: "method",
          description: "Ch·ªâ ƒë·ªãnh fields c·∫ßn include/exclude ho·∫∑c t·∫°o computed fields. T∆∞∆°ng ƒë∆∞∆°ng $project.",
          usage: "aggregate.project(arg)",
          example: "const result = await User.aggregate()\n  .project({\n    name: 1,\n    email: 1,\n    fullName: { $concat: ['$firstName', ' ', '$lastName'] },\n    isAdult: { $gte: ['$age', 18] },\n    _id: 0\n  });"
        },
        {
          name: "read()",
          category: "aggregate",
          type: "method",
          description: "Thi·∫øt l·∫≠p read preference cho aggregation.",
          usage: "aggregate.read(pref, tags)",
          example: "const result = await User.aggregate(pipeline)\n  .read('secondary', [{ region: 'us-west' }]);\n// ƒê·ªçc t·ª´ secondary replica ·ªü region us-west"
        },
        {
          name: "readConcern()",
          category: "aggregate",
          type: "method",
          description: "Thi·∫øt l·∫≠p read concern cho aggregation.",
          usage: "aggregate.readConcern(level)",
          example: "const result = await User.aggregate(pipeline)\n  .readConcern('majority');\n// ƒê·∫£m b·∫£o ƒë·ªçc data ƒë√£ ƒë∆∞·ª£c majority acknowledge"
        },
        {
          name: "redact()",
          category: "aggregate",
          type: "method",
          description: "Conditionally filter document content. T∆∞∆°ng ƒë∆∞∆°ng $redact stage.",
          usage: "aggregate.redact(arg)",
          example: "const result = await Document.aggregate()\n  .redact({\n    $cond: {\n      if: { $gte: ['$accessLevel', '$requiredLevel'] },\n      then: '$$KEEP',\n      else: '$$PRUNE'\n    }\n  });"
        },
        {
          name: "replaceRoot()",
          category: "aggregate",
          type: "method",
          description: "Thay th·∫ø document root v·ªõi field kh√°c. T∆∞∆°ng ƒë∆∞∆°ng $replaceRoot stage.",
          usage: "aggregate.replaceRoot(newRoot)",
          example: "const result = await User.aggregate()\n  .replaceRoot({ newRoot: '$profile' });\n// Document root gi·ªù l√† profile object"
        },
        {
          name: "sample()",
          category: "aggregate",
          type: "method",
          description: "L·∫•y sample ng·∫´u nhi√™n documents. T∆∞∆°ng ƒë∆∞∆°ng $sample stage.",
          usage: "aggregate.sample(size)",
          example: "const randomUsers = await User.aggregate()\n  .match({ active: true })\n  .sample(10);\n// L·∫•y 10 active users ng·∫´u nhi√™n"
        },
        {
          name: "search()",
          category: "aggregate",
          type: "method",
          description: "MongoDB Atlas Search integration. T∆∞∆°ng ƒë∆∞∆°ng $search stage.",
          usage: "aggregate.search(arg)",
          example: "// Ch·ªâ ho·∫°t ƒë·ªông v·ªõi MongoDB Atlas\nconst result = await Article.aggregate()\n  .search({\n    index: 'article_index',\n    text: {\n      query: 'javascript mongodb',\n      path: ['title', 'content']\n    }\n  });"
        },
        {
          name: "session()",
          category: "aggregate",
          type: "method",
          description: "Thi·∫øt l·∫≠p session cho aggregation (ƒë·ªÉ s·ª≠ d·ª•ng transactions).",
          usage: "aggregate.session(session)",
          example: "const session = await mongoose.startSession();\nconst result = await User.aggregate(pipeline)\n  .session(session);\n// Aggregation ch·∫°y trong session context"
        },
        {
          name: "skip()",
          category: "aggregate",
          type: "method",
          description: "B·ªè qua s·ªë documents ƒë·∫ßu ti√™n. T∆∞∆°ng ƒë∆∞∆°ng $skip stage.",
          usage: "aggregate.skip(num)",
          example: "const result = await User.aggregate()\n  .match({ active: true })\n  .sort({ createdAt: -1 })\n  .skip(20)\n  .limit(10); // Pagination: page 3, 10 items per page"
        },
        {
          name: "sort()",
          category: "aggregate",
          type: "method",
          description: "S·∫Øp x·∫øp documents theo fields. T∆∞∆°ng ƒë∆∞∆°ng $sort stage.",
          usage: "aggregate.sort(arg)",
          example: "const result = await User.aggregate()\n  .match({ active: true })\n  .sort({ \n    department: 1,    // TƒÉng d·∫ßn\n    salary: -1,       // Gi·∫£m d·∫ßn\n    name: 1           // TƒÉng d·∫ßn\n  });"
        },
        {
          name: "sortByCount()",
          category: "aggregate",
          type: "method",
          description: "Group theo field v√† sort theo count. T∆∞∆°ng ƒë∆∞∆°ng $sortByCount stage.",
          usage: "aggregate.sortByCount(arg)",
          example: "const result = await User.aggregate()\n  .sortByCount('$department');\n// [{ _id: 'engineering', count: 50 }, { _id: 'design', count: 30 }, ...]"
        },
        {
          name: "then()",
          category: "aggregate",
          type: "method",
          description: "Th√™m success handler cho aggregation Promise.",
          usage: "aggregate.then(onFulfilled, onRejected)",
          example: "User.aggregate([\n  { $match: { active: true } },\n  { $group: { _id: '$department', count: { $sum: 1 } } }\n])\n.then(result => {\n  console.log('Department stats:', result);\n})\n.catch(err => {\n  console.error('Aggregation failed:', err);\n});"
        },
        {
          name: "unionWith()",
          category: "aggregate",
          type: "method",
          description: "Union k·∫øt qu·∫£ v·ªõi collection kh√°c. T∆∞∆°ng ƒë∆∞∆°ng $unionWith stage. MongoDB 4.4+.",
          usage: "aggregate.unionWith(options)",
          example: "const result = await User.aggregate()\n  .match({ active: true })\n  .unionWith({\n    coll: 'admins',\n    pipeline: [\n      { $match: { role: 'admin' } },\n      { $addFields: { userType: 'admin' } }\n    ]\n  })\n  .addFields({ userType: { $ifNull: ['$userType', 'regular'] } });"
        },
        {
          name: "unwind()",
          category: "aggregate",
          type: "method",
          description: "T√°ch array field th√†nh separate documents. T∆∞∆°ng ƒë∆∞∆°ng $unwind stage.",
          usage: "aggregate.unwind(arg)",
          example: "const result = await User.aggregate()\n  .unwind('$skills') // M·ªói skill th√†nh 1 document ri√™ng\n  .group({\n    _id: '$skills.name',\n    avgLevel: { $avg: '$skills.level' },\n    userCount: { $sum: 1 }\n  });\n\n// Ho·∫∑c v·ªõi options\nconst result2 = await User.aggregate()\n  .unwind({\n    path: '$skills',\n    includeArrayIndex: 'skillIndex',\n    preserveNullAndEmptyArrays: true\n  });"
        },
        {
          name: "[Symbol.asyncIterator]()",
          category: "aggregate",
          type: "method",
          description: "Cho ph√©p s·ª≠ d·ª•ng for-await-of loop v·ªõi aggregation cursor.",
          usage: "for await (const doc of aggregate) { ... }",
          example: "const aggregation = User.aggregate([\n  { $match: { active: true } },\n  { $project: { name: 1, email: 1 } }\n]);\n\nfor await (const user of aggregation) {\n  console.log('Processing user:', user.name);\n  // X·ª≠ l√Ω t·ª´ng user m·ªôt c√°ch memory-efficient\n}"
        }
      ],
      // VirtualType API Data - Th√™m v√†o object apiData trong HTML
      virtualtype: [
        {
          name: "VirtualType()",
          category: "virtualtype",
          type: "constructor",
          description: "Constructor ƒë·ªÉ t·∫°o VirtualType instance. ƒê·∫°i di·ªán cho virtual field kh√¥ng ƒë∆∞·ª£c l∆∞u trong database.",
          usage: "new VirtualType(options, name)",
          example: "const virtual = new mongoose.VirtualType({}, 'fullName');\n// T·∫°o virtual field m·ªõi"
        },
        {
          name: "applyGetters()",
          category: "virtualtype",
          type: "method",
          description: "√Åp d·ª•ng t·∫•t c·∫£ getter functions ƒë·ªÉ t√≠nh to√°n gi√° tr·ªã virtual field.",
          usage: "virtualType.applyGetters(value, scope)",
          example: "const fullNameVirtual = userSchema.virtual('fullName')\n  .get(function() {\n    return this.firstName + ' ' + this.lastName;\n  });\n\n// Internal: virtual s·∫Ω g·ªçi applyGetters khi truy c·∫≠p\nconst result = fullNameVirtual.applyGetters(null, userDoc);"
        },
        {
          name: "applySetters()",
          category: "virtualtype",
          type: "method",
          description: "√Åp d·ª•ng t·∫•t c·∫£ setter functions khi g√°n gi√° tr·ªã cho virtual field.",
          usage: "virtualType.applySetters(value, scope)",
          example: "const fullNameVirtual = userSchema.virtual('fullName')\n  .set(function(name) {\n    const parts = name.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1];\n  });\n\n// Internal: virtual s·∫Ω g·ªçi applySetters khi g√°n gi√° tr·ªã\nfullNameVirtual.applySetters('John Doe', userDoc);"
        },
        {
          name: "get()",
          category: "virtualtype",
          type: "method",
          description: "ƒê·ªãnh nghƒ©a getter function cho virtual field. Function n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi khi truy c·∫≠p virtual.",
          usage: "virtualType.get(fn)",
          example: "userSchema.virtual('fullName')\n  .get(function() {\n    return `${this.firstName} ${this.lastName}`;\n  });\n\n// S·ª≠ d·ª•ng\nconst user = new User({ firstName: 'John', lastName: 'Doe' });\nconsole.log(user.fullName); // 'John Doe'"
        },
        {
          name: "set()",
          category: "virtualtype",
          type: "method",
          description: "ƒê·ªãnh nghƒ©a setter function cho virtual field. Function n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi khi g√°n gi√° tr·ªã.",
          usage: "virtualType.set(fn)",
          example: "userSchema.virtual('fullName')\n  .set(function(name) {\n    const parts = name.split(' ');\n    this.firstName = parts[0];\n    this.lastName = parts[1] || '';\n  });\n\n// S·ª≠ d·ª•ng\nconst user = new User();\nuser.fullName = 'John Doe';\nconsole.log(user.firstName); // 'John'\nconsole.log(user.lastName);  // 'Doe'"
        }
      ]
    };

    // Category information
    const categoryInfo = {
      all: {
        title: "T·∫•t c·∫£ API",
        description: "Hi·ªÉn th·ªã t·∫•t c·∫£ API c·ªßa Mongoose"
      },
      mongoose: {
        title: "Mongoose Core",
        description: "API ch√≠nh c·ªßa Mongoose - k·∫øt n·ªëi, c·∫•u h√¨nh v√† qu·∫£n l√Ω global"
      },
      schema: {
        title: "Schema API",
        description: "API ƒë·ªÉ ƒë·ªãnh nghƒ©a c·∫•u tr√∫c document, validation v√† middleware"
      },
      connection: {
        title: "Connection API",
        description: "API qu·∫£n l√Ω k·∫øt n·ªëi t·ªõi MongoDB - m·ªü/ƒë√≥ng connection, transactions, change streams"
      },
      document: {
        title: "Document API",
        description: "API ƒë·ªÉ l√†m vi·ªác v·ªõi document instances - validation, save, populate, modify tracking"
      },
      model: {
        title: "Model API",
        description: "API cho Model class - CRUD operations, queries, aggregation, indexing"
      },
      query: {
        title: "Query API",
        description: "API ƒë·ªÉ x√¢y d·ª±ng v√† th·ª±c thi MongoDB queries - filtering, sorting, pagination, geospatial"
      }, aggregate: {
        title: "Aggregate API",
        description: "API cho MongoDB Aggregation Pipeline - group, lookup, project, facet, geospatial operations"
      }, virtualtype: {
        title: "VirtualType API",
        description: "API cho Virtual Fields - computed properties kh√¥ng l∆∞u trong database, getters/setters"
      }
    };

    let currentCategory = 'all';
    let currentType = 'all';
    let allData = [];

    // Flatten all data
    function flattenData() {
      allData = [];
      Object.keys(apiData).forEach(category => {
        apiData[category].forEach(item => {
          allData.push({
            ...item,
            categoryName: category
          });
        });
      });
    }

    // Update statistics
    function updateStats() {
      const stats = {
        total: allData.length,
        constructors: allData.filter(item => item.type === 'constructor').length,
        methods: allData.filter(item => item.type === 'method').length,
        properties: allData.filter(item => item.type === 'property').length,
        statics: allData.filter(item => item.type === 'static').length
      };

      const statsContainer = document.getElementById('statsContainer');
      statsContainer.innerHTML = `
                <div class="stat-card">
                    <span class="stat-number">${stats.total}</span>
                    <div class="stat-label">T·ªïng API</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${stats.constructors}</span>
                    <div class="stat-label">Constructors</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${stats.methods}</span>
                    <div class="stat-label">Methods</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${stats.properties}</span>
                    <div class="stat-label">Properties</div>
                </div>
                <div class="stat-card">
                    <span class="stat-number">${stats.statics}</span>
                    <div class="stat-label">Static</div>
                </div>
            `;
    }

    // Create filter buttons
    function createFilters() {
      // Category filters
      const categoryFilters = document.getElementById('categoryFilters');
      const categories = ['all', ...Object.keys(apiData)];

      categoryFilters.innerHTML = categories.map(cat =>
        `<button class="filter-btn category-btn ${cat === 'all' ? 'active' : ''}" 
                         onclick="filterByCategory('${cat}')">${categoryInfo[cat]?.title || cat}</button>`
      ).join('');

      // Type filters
      const typeFilters = document.getElementById('typeFilters');
      const types = ['all', 'constructor', 'method', 'property', 'static'];

      typeFilters.innerHTML = types.map(type =>
        `<button class="filter-btn ${type === 'all' ? 'active' : ''}" 
                         onclick="filterByType('${type}')">${type === 'all' ? 'T·∫•t c·∫£' : type}</button>`
      ).join('');
    }

    // Filter by category
    function filterByCategory(category) {
      currentCategory = category;

      // Update active button
      document.querySelectorAll('.category-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');

      // Update category info
      const info = categoryInfo[category];
      document.getElementById('categoryTitle').textContent = info.title;
      document.getElementById('categoryDescription').textContent = info.description;

      populateTable();
    }

    // Filter by type
    function filterByType(type) {
      currentType = type;

      // Update active button
      document.querySelectorAll('#typeFilters .filter-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');

      populateTable();
    }

    // Populate table with filtered data
    function populateTable() {
      const tbody = document.getElementById('tableBody');

      let filteredData = allData;

      // Filter by category
      if (currentCategory !== 'all') {
        filteredData = filteredData.filter(item => item.categoryName === currentCategory);
      }

      // Filter by type
      if (currentType !== 'all') {
        filteredData = filteredData.filter(item => item.type === currentType);
      }

      if (filteredData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="loading">üòï Kh√¥ng t√¨m th·∫•y API n√†o</td></tr>';
        return;
      }

      tbody.innerHTML = '';

      filteredData.forEach(item => {
        const row = document.createElement('tr');

        const categoryClass = `category-${item.categoryName}`;
        const typeClass = `type-${item.type}`;

        row.innerHTML = `
                    <td><span class="api-name">${item.name}</span></td>
                    <td><span class="category-badge ${categoryClass}">${item.categoryName}</span></td>
                    <td><span class="type-badge ${typeClass}">${item.type}</span></td>
                    <td class="description">${item.description}</td>
                    <td><div class="code-block">${item.example}</div></td>
                `;

        tbody.appendChild(row);
      });
    }

    // Search functionality
    function filterTable(searchTerm) {
      const rows = document.querySelectorAll('#tableBody tr');

      rows.forEach(row => {
        const text = row.textContent.toLowerCase();
        if (text.includes(searchTerm.toLowerCase())) {
          row.style.display = '';
        } else {
          row.style.display = 'none';
        }
      });
    }

    // Export to Excel
    function exportToExcel() {
      // Prepare data for Excel
      const excelData = allData.map(item => ({
        'T√™n API': item.name,
        'Danh m·ª•c': item.categoryName,
        'Lo·∫°i': item.type,
        'M√¥ t·∫£': item.description,
        'C√°ch s·ª≠ d·ª•ng': item.usage,
        'V√≠ d·ª•': item.example
      }));

      // Create workbook
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.json_to_sheet(excelData);

      // Set column widths
      const colWidths = [
        { wch: 35 }, // T√™n API
        { wch: 15 }, // Danh m·ª•c
        { wch: 15 }, // Lo·∫°i
        { wch: 60 }, // M√¥ t·∫£
        { wch: 50 }, // C√°ch s·ª≠ d·ª•ng
        { wch: 80 }  // V√≠ d·ª•
      ];
      worksheet['!cols'] = colWidths;

      // Add worksheet to workbook
      XLSX.utils.book_append_sheet(workbook, worksheet, "Mongoose Complete API");

      // Create and download file
      XLSX.writeFile(workbook, 'Mongoose_Complete_API_Reference.xlsx');

      // Show success message
      alert('‚úÖ File Excel ƒë√£ ƒë∆∞·ª£c t·∫°o v√† t·∫£i xu·ªëng th√†nh c√¥ng!\nüìÅ T√™n file: Mongoose_Complete_API_Reference.xlsx');
    }

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', function () {
      flattenData();
      updateStats();
      createFilters();
      populateTable();
    });
  </script>
</body>

</html>
